---
title: "Bayesian models"
author: "Suparna Chaudhry and Andrew Heiss"
date: "`r format(Sys.time(), '%F')`"
output: 
  html_document:
    code_folding: hide
editor_options: 
  chunk_output_type: console
---


```{r echo=FALSE, warning=FALSE, message=FALSE}
if (isTRUE(getOption('knitr.in.progress'))) {
  knitr::read_chunk(here::here("lib", "models-chunks.R"))
} else {
  source(here::here("lib", "models-chunks.R"))
  # qwraps2::lazyload_cache_dir("04_bayesian-models_cache/html")
}
```

```{r load-libraries, message=FALSE}
```

```{r load-data, cache=TRUE, message=FALSE}
```

```{r load-bayesian-models, cache=TRUE}
h1.raw <- here("Data", "data_cache", "models_bayes_h1.rds")
h2.raw <- here("Data", "data_cache", "models_bayes_h2.rds")
h3.domestic.raw <- here("Data", "data_cache", "models_bayes_h3_domestic.rds")
h3.foreign.raw <- here("Data", "data_cache", "models_bayes_h3_foreign.rds")

if (file.exists(h1.raw) & file.exists(h2.raw) & 
    file.exists(h3.domestic.raw) & file.exists(h3.foreign.raw)) {
  mods.h1.next_year.raw.bayes <- readRDS(h1.raw)
  mods.h2.next_year.raw.bayes <- readRDS(h2.raw)
  mods.h3.dom.next_year.raw <- readRDS(h3.domestic.raw)
  mods.h3.foreign.next_year.raw <- readRDS(h3.foreign.raw)
} else {
  stop("Run Data/run_bayes_remote.R to generate the model data")
}
```

```{r furrr, message=FALSE}
library(furrr)
plan(multiprocess)
```

```{r helpful-functions}
```

```{r huxreg-functions}
# Wrappers around tidy.stanreg and glance.stanreg so that we can exponentiate
# coefficients in huxreg
tidy.expmcmc <- function(x, ...) {
  # This is hacky, but it works. Remove the custom "expmcmc" class so that
  # regular broom functions work on x
  class(x) <- class(x)[class(x) != "expmcmc"]
  
  has_confint <- hasArg(conf.int)
  non_exponentiated <- tidy(x, ...)
  
  if (has_confint) {
    exponentiated <- non_exponentiated %>% 
      mutate_at(vars(estimate, conf.low, conf.high), exp)
  } else {
    exponentiated <- non_exponentiated %>% 
      mutate_at(vars(estimate), exp)
  }
  
  return(exponentiated)
}

glance.expmcmc <- function(x, ...) {
  class(x) <- class(x)[class(x) != "expmcmc"]
  return(glance(x, ...))
}

add_expmcmc <- function(x) {
  class(x) <- c("expmcmc", class(x))
  return(x)
}
```

---

## H~1~: Donors reduce aid in response to legislation

> **H~1~**: In response to restrictive NGO legislation, bilateral, multilateral, and private donors may reduce their aid to repressive countries.

$$ln( \text{ODA}_{\text{OECD}} )_{i, t+1} = \text{NGO legislation}_{it} + \text{controls}_{it}$$

Our dependent variable for this hypothesis is the log of ODA (constant 2011 dollars), leaded by one year so we don't have to lag every other independent variable. As a robustness check, we also include models with log ODA leaded by 2 years and 5 years to account the implementation period following the passage of a law.

We look at NGO legislation in a few different ways:

- `barriers.total`: Number of anti-NGO legal barriers in a country-year
- `barriers.total_new`: Indicator marking if a new anti-NGO barrier was passed in a country year
- `advocacy + entry + funding`: Number of anti-NGO legal barriers by type of barrier
- `advocacy_new + entry_new + funding_new`: Indicators marking new type of barrier
- `csre`: Civil society regulatory environment index (CSRE), ranging from roughly -4 to 4 (higher values = better civil society regulations)

```{r h1-models-bayes-1, warning=FALSE, message=FALSE}
# Get model details and parameters
mods.h1.next_year.bayes <- mods.h1.next_year.raw.bayes %>%
  gather(model.name, model, -m) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy),
         augment = model %>% map(broom::augment)) %>%
  filter(m != "original")
```


### MCMC diagnostics {.tabset .tabset-fade .tabset-pills}

#### Check fit

We use one of the imputed models (`mod.h1.barriers.total`) to check for fit and convergence.

```{r h1-diagnostics-bayes}
model.to.check <- mods.h1.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h1.barriers.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]
```

How well does the posterior predictive distribution fit the observed outcome? Not great, but not perfectly. The actual distribution is bimodal, with a bunch of zeros, and the model gets the two peaks, but they're shallow. We can live with it, though.

```{r h1-diag-density}
pp_check(model.to.check, plotfun = "ppc_dens_overlay", nreps = 5) + 
  theme_donors()
```

#### Check convergence

What about chain convergence? These should look like tops if everything converges, with no observations at 0 in the mean Metropolis-Hastings aceptance panel.

```{r h1-diag-divergence}
rstan::stan_diag(model.to.check, information = "divergence")
```


### Merging MCMC chains

Merging the MCMC chains is relatively easy, but then working with the 20,000 rows of simulations is trickier, since merging makes the model a `data_frame` intead of a `stanreg` object, meaning all the convenience funcions like `posterior_predict()` don't work anymore. That means lots of math. Ugh.

So instead, we do two things. We calculate the posterior median and MD by just merging all the MCMC chains from all imputations. Becuase `posterior_predict()` doesn't work on merged chains like this, we run `posterior_predict()` on each imputation and then take the mean of each imputation's credible intervals. This should be okay—taking the median of medians (or [mean of means](http://stats.stackexchange.com/q/133138/3025)) will yield the same value if the group sizes are the same (thus avoiding Simpson's Paradox). Like this:

```{r median-of-medians}
group1 = c(1, 2, 3, 4)
group2 = c(5, 6, 7, 8)

median(c(group1, group2))
median(c(median(group1), median(group2)))
```

If it's a little off, it should be okay—it'll be off by an order of 0.001ish. 


### Results {.tabset .tabset-fade .tabset-pills}

#### Coefficients

```{r h1-plot-coefs, fig.width=5.5, fig.height=3}
vars.to.plot <- c("barriers.total_within", "barriers.total_between",
                  "barriers.total_new",
                  "advocacy_within", "advocacy_between", 
                  "entry_within", "entry_between", 
                  "funding_within", "funding_between",
                  "advocacy_new", "entry_new", "funding_new",
                  "csre_within", "csre_between")

mods.h1.melded <- bayes.meld(mods.h1.next_year.bayes,
                             vars.to.plot)$melded.summary

plot.data <- mods.h1.melded %>%
  left_join(coef.names.all, by = "term") %>%
  left_join(model.names, by = c("model.name" = "model")) %>% 
  mutate(term = factor(term, levels = vars.to.plot, ordered = TRUE)) %>%
  arrange(desc(term)) %>%
  mutate(term_plot = ordered(fct_inorder(term_plot_short))) %>%
  mutate(coef.type = case_when(
    str_detect(.$term, "_within") ~ "Within",
    str_detect(.$term, "_between") ~ "Between",
    TRUE ~ "Not split"
  )) %>% 
  mutate(coef.type = factor(coef.type, levels = c("Within", "Between", "Not split"),
                            ordered = TRUE)) %>%
  mutate(model_clean = factor(model_clean, levels = rev(unique(model_clean)), ordered = TRUE))

fig.coefs.h1 <- ggplot(plot.data, aes(x = med, y = term_plot, 
                                      xmin = `5%`, xmax = `95%`, colour = model_clean)) +
  geom_vline(xintercept = 0, colour = "black", size = 0.5) + 
  geom_pointrangeh(size = 0.5, fatten = 3) +
  labs(x = "Posterior median change in log ODA in following year", y = NULL) +
  scale_colour_manual(values = model.colors, name = "Models") +
  expand_limits(x = c(-2, 1)) +
  guides(color = guide_legend(override.aes = list(size = 0.25))) +
  theme_donors() + 
  theme(legend.position = c(0.5, 0.02), legend.justification = c(0.15, 0),
        axis.title.x = element_text(hjust = 0)) +
  facet_wrap(~ coef.type, scales = "free", ncol = 2)
fig.coefs.h1

fig.save.cairo(fig.coefs.h1, filename = "fig-coefs-h1-bayes",
               width = 5.5, height = 3)
```

#### Complete results in a table

```{r h1-table, results="asis", warning=FALSE}
caption <- "The effect of anti-NGO legislation on OECD overseas development assistance (ODA) in the following year (H~1~), full models. Each cell contains the parameter's posterior median, the 95% credible interval, and the probability that the parameter is greater than zero. {#tbl:h1-coefs}"
note <- c("Dependent variable log transformed.")
table.h1 <- bayesgazer(mods.h1.next_year.bayes,
                       caption = caption, note = note)

cat(table.h1)
cat(table.h1, file = here("Output", "tbl-h1-coefs-bayes.md"))
```

#### Complete results (nonimputed)

```{r h1-no-imputation, message=FALSE, warning=FALSE}
mods.h1.next_year.bayes.no.imp <- mods.h1.next_year.raw.bayes %>%
  filter(m == "original") %>% 
  gather(model.name, model, -m) %>%
  mutate(glance = model %>% map(glance),
         tidy = model %>% map(tidy))

h1_coefs <- mods.h1.next_year.bayes.no.imp %>%
  unnest(tidy) %>% 
  filter(!duplicated(term, fromLast = TRUE)) %>%
  mutate(term_join = str_replace(term, "TRUE", "")) %>% 
  left_join(coef.names.all, by = c("term_join" = "term")) %>% 
  filter(term != "(Intercept)")

h1_coefs_named <- h1_coefs %>% pull(term) %>% 
  set_names(h1_coefs$term_clean)

huxreg(mods.h1.next_year.bayes.no.imp$model,
       coefs = c(h1_coefs_named, Constant = "(Intercept)"),
       stars = NULL,
       tidy_args = list(conf.int = TRUE, conf.level = 0.9),
       error_format = "({conf.low}, {conf.high})")
```

### Model diagnostics

Country intercepts vary with an SD of 0.07 (etc.), year intercepts vary with an SD of 0.07 (etc.), and the SD of error not accounted for by either within-country or within-year variability is 3.02 (etc.)


### Predicted ODA

Here, for the sake of computational efficiency and speed, we only use one of the imputed datasets for predictions. Technically we should base the predictions on all the merged chains, but (1) there's no function that can handle that, (2) it would take forever to run predictions on each individual imputation and then combine the predictions, and (3) these are posterior medians anyway from ostensibly the same-ish distribution—quintupling the number of chains to simulate is overkill for drawing a picture.

```{r h1-predict-total, warning=FALSE, message=FALSE, cache=TRUE}
model <- mods.h1.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h1.barriers.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]

# For whatever reason, stanreg objects return the full data frame used in the
# model, not just the model matrix, when calling object$data. model.frame()
# chokes on object$formula because of (1 | x) grouping terms, but
# get_all_vars() works.
new.data <- get_all_vars(model$formula, data = model$data) %>%
  select(-c(barriers.total_within, year, cowcode)) %>%
  summarise_all(typical) %>%
  mutate(id = 1) %>%
  right_join(expand.grid(barriers.total_within = seq(-3, 4, 0.5),
                         cowcode = 1000:1049,
                         year = 1981:2012,
                         id = 1), by = "id") %>% select(-id)

predicted.h1.barriers.total <- new.data %>%
  nest(-cowcode) %>%
  mutate(predicted = future_map(.x = data, ~ generate_predictions(.x))) %>%
  unnest()

df.plot.data.h1 <- predicted.h1.barriers.total %>%
  group_by(cowcode, barriers.total_within) %>%
  summarise_at(vars(predicted), funs(mean(.))) %>%
  ungroup()

df.plot.data.mean.h1 <- df.plot.data.h1 %>%
  group_by(barriers.total_within) %>%
  summarise(predicted = mean(predicted)) %>%
  mutate(cowcode = 1)  # Fake country so the line plots
```

```{r h1-predict-individual, warning=FALSE, message=FALSE, cache=TRUE}
barriers.indiv.clean.names <- tribble(
  ~barrier, ~barrier.clean,
  "advocacy_within", "Barriers to advocacy",
  "entry_within", "Barriers to entry",
  "funding_within", "Barriers to funding"
)

model <- mods.h1.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h1.type.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]

hypothetical.bounds <- get_all_vars(model$formula, data = model$data) %>%
  select(advocacy_within, entry_within, funding_within) %>%
  summarise_all(funs(min, max)) %>%
  gather(key, value) %>%
  mutate(value = round(value, 0)) %>%
  # Have to separate on _m because of multiple _s, then re-add the m
  separate(key, into = c("term", "variable"), sep = "_m") %>%
  mutate(variable = paste0("m", variable)) %>%
  spread(variable, value)

new.data.hypothetical.nested <- hypothetical.bounds %>%
  nest(-term) %>%
  mutate(newdata = map2(.x = data, .y = term,
                        ~ expand.grid(term = seq(.x$min, .x$max, by = 0.5),
                                      cowcode = 1000:1049,
                                      year = 1981:2012,
                                      id = 1) %>%
                          # Rename the term column to the actual term name
                          magrittr::set_colnames(c(.y, colnames(.)[-1]))))

new.data.hypothetical <- as_tibble(bind_rows(new.data.hypothetical.nested$newdata)) %>%
  mutate_at(vars(contains("within")), funs(ifelse(is.na(.), 0, .)))

new.data <- get_all_vars(model$formula, data = model$data) %>%
  select(-c(advocacy_within, entry_within, funding_within, year, cowcode)) %>%
  summarise_all(typical) %>%
  mutate(id = 1) %>%
  right_join(new.data.hypothetical, by = "id") %>% select(-id)

predicted.h1.barriers.individual <- new.data %>%
  nest(-cowcode) %>%
  mutate(predicted = future_map(.x = data, ~ generate_predictions(.x))) %>%
  unnest()

df.plot.data.indiv.h1 <- predicted.h1.barriers.individual %>%
  gather(barrier, barrier.value, c(advocacy_within, entry_within, funding_within)) %>%
  group_by(cowcode, barrier.value, barrier) %>%
  summarise_at(vars(predicted), funs(mean(.))) %>%
  left_join(barriers.indiv.clean.names, by = "barrier")

df.plot.data.mean.indiv.h1 <- df.plot.data.indiv.h1 %>%
  group_by(barrier, barrier.value) %>%
  summarise(predicted = mean(predicted)) %>%
  mutate(cowcode = 1) %>%  # Fake country so the line plots
  left_join(barriers.indiv.clean.names, by = "barrier")
```

```{r h1-predict-both, warning=FALSE, fig.width=5.5, fig.height=3.5}
# Combine the two plot data frames
df.plot.data.both.h1 <- df.plot.data.h1 %>%
  mutate(barrier = "barriers.total_within", barrier.clean = "Total barriers") %>%
  rename(barrier.value = barriers.total_within) %>%
  bind_rows(df.plot.data.indiv.h1) %>%
  mutate(barrier.clean = ordered(fct_inorder(barrier.clean)),
         highlight = ifelse(barrier.clean == "Total barriers", TRUE, FALSE))

df.plot.data.mean.both.h1 <- df.plot.data.mean.h1 %>%
  mutate(barrier = "barriers.total_within", barrier.clean = "Total barriers") %>%
  rename(barrier.value = barriers.total_within) %>%
  bind_rows(df.plot.data.mean.indiv.h1) %>%
  mutate(barrier.clean = ordered(fct_inorder(barrier.clean)))

# Create data frame for highlighting the total panel
df.panel.highlight.h1 <- df.plot.data.both.h1 %>%
  distinct(barrier.clean, highlight)

fig.predicted.h1.barriers.both <- ggplot(df.plot.data.both.h1, 
                                         aes(x = barrier.value, y = expm1(predicted), 
                                             group = cowcode)) + 
  geom_rect(data = df.panel.highlight.h1, aes(fill = highlight), inherit.aes = FALSE,
            xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf, alpha = 0.15) +
  geom_vline(xintercept = 0, colour = "black", size = 0.5) + 
  geom_smooth(method = "lm", size = 0.1, alpha = 0.1, 
              colour = simulation.individual) +
  geom_smooth(data = df.plot.data.mean.both.h1, size = 1.5, 
              method = "lm", colour = simulation.mean) +
  labs(x = "Difference from average number of anti-NGO barriers in country (within effects)",
       y = "Predicted ODA in the following year") +
  scale_y_continuous(labels = dollar, trans = log1p_trans()) +
  scale_fill_manual(values = c(NA, "grey50"), guide = FALSE) +
  facet_wrap(~ barrier.clean, scales = "free_x") +
  theme_donors() +
  theme(axis.title.x = element_text(hjust = 0))
fig.predicted.h1.barriers.both

fig.display.both.h1 <- fig.predicted.h1.barriers.both + 
  labs(title = "Donors reduce aid more in response to\nadditional advocacy-focused anti-NGO laws",
       subtitle = "Predicted foreign aid (ODA) across range of differences from the average number of\nanti-NGO laws in a hypothetical average country; dark line shows average of\n500 draws from posterior distribution",
       caption = "Chaudhry and Heiss (2017)") + 
  theme_donors(11)

fig.save.cairo(fig.predicted.h1.barriers.both, filename = "fig-predicted-h1",
               width = 5.5, height = 3.5)
```


---

## H~2~: Donors shift aid to tamer causes

> **H~2~**: As restrictive laws against NGOs are enacted, donors start increasing funds for 'tamer' causes, and decreasing funds for politically sensitive causes.

Our dependent variable for this hypothesis is the percentage of ODA (still in constant 2011 dollars) allocated for contentious purposes, again leaded by one year. We classify contentious aid as any project focused on government and civil society (DAC codes 150 and 151) or conflict prevention and resolution, peace and security (DAC code 152).

Working with proportion data, however, poses interesting mathematical and methodological challenges, since the range of possible outcomes is limited to a value between 0 and 1. Treating proportion variables in a mixed model is technically possible, but it yields predicitions that go beyond the allowable range of values (1.13, -0.5, etc.). Treating the proportion as a binomial variable is also possible and is indeed [one of the ways to use the `glm()` function](http://stackoverflow.com/a/9111904/120898) in R. However, this entails considering the proportion as a ratio of success and failures. In this case, treating a dollar of contentious aid as a success feels off, especially since aid amounts aren't independence events—it's not like each dollar of aid goes through a probabalistic process likek a coin flip. Another solution is to use [beta regression](https://cran.r-project.org/package=betareg), which [constrains the outcome variable to values between 0 and 1](http://www.theanalysisfactor.com/zero-one-inflated-beta-models-for-proportion-data/), but unfortunately does not allow for values of exactly 0 or 1. Zero-and-one inflated beta regression models make adjustments for this, but [they aren't very popular](https://CRAN.R-project.org/package=zoib) and definitely don't accont for random effects and mixed models. 

[One recommendation by Ben Bolker](https://stat.ethz.ch/pipermail/r-sig-mixed-models/2011q1/015422.html), the maintainer of [`lme4`](https://cran.r-project.org/package=lme4), is to use a logit transformation of the dependent variable in `lmer()` models. This seems to be [standard practice in political science research](https://acrowinghen.com/2014/04/24/interpreting-coefficients-from-a-logit-linear-model-with-a-proportional-dependent-variable/), too. Logit transformations still can't handle values of exactly 0 or 1, though, so we [winsorize](https://en.wikipedia.org/wiki/Winsorizing) those values by adding or subtracting 0.001 to the extremes.

We thus use a logit-linear model of the ratio of contentious aid to non-contentious aid:

$$ln( \frac{\text{contentious ODA}_{\text{OECD}}}{\text{noncontentious ODA}_{\text{OECD}}} )_{i, t+1} = \text{NGO legislation}_{it} + \text{controls}_{it}$$

We look at NGO legislation in the same ways as H~1~ and use the same controls.

```{r h2-models-bayes, warning=FALSE, message=FALSE}
# Get model details and parameters
mods.h2.next_year.bayes <- mods.h2.next_year.raw.bayes %>%
  gather(model.name, model, -m) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy),
         augment = model %>% map(broom::augment)) %>%
  filter(m != "original")
```


### MCMC diagnostics {.tabset .tabset-fade .tabset-pills}

#### Check fit

Again, use one of the imputed models (`mod.h2.barriers.total`) to check for fit and convergence.

```{r h2-diagnostics-bayes}
model.to.check <- mods.h2.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h2.barriers.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]
```

Posterior predictive distribution vs. observed outcome?

```{r h2-diag-density}
pp_check(model.to.check, plotfun = "ppc_dens_overlay", nreps = 5) + 
  theme_donors()
```

#### Check convergence

Chain convergence:

```{r h2-diag-divergence}
rstan::stan_diag(model.to.check, information = "divergence")
```


### Results {.tabset .tabset-fade .tabset-pills}

#### Coefficients

```{r h2-plot-coefs, fig.width=5.5, fig.height=3}
vars.to.plot <- c("barriers.total_within", "barriers.total_between",
                  "barriers.total_new",
                  "advocacy_within", "advocacy_between", 
                  "entry_within", "entry_between", 
                  "funding_within", "funding_between",
                  "advocacy_new", "entry_new", "funding_new",
                  "csre_within", "csre_between")

mods.h2.melded <- bayes.meld(mods.h2.next_year.bayes,
                             vars.to.plot, exponentiate = TRUE)$melded.summary

plot.data <- mods.h2.melded %>%
  left_join(coef.names.all, by = "term") %>%
  left_join(model.names, by = c("model.name" = "model")) %>% 
  mutate(term = factor(term, levels = vars.to.plot, ordered = TRUE)) %>%
  arrange(desc(term)) %>%
  mutate(term_plot = ordered(fct_inorder(term_plot_short))) %>%
  mutate(coef.type = case_when(
    str_detect(.$term, "_within") ~ "Within",
    str_detect(.$term, "_between") ~ "Between",
    TRUE ~ "Not split"
  )) %>% 
  mutate(coef.type = factor(coef.type, levels = c("Within", "Between", "Not split"),
                            ordered = TRUE)) %>%
  mutate(model_clean = factor(model_clean, levels = rev(unique(model_clean)), ordered = TRUE))

fig.coefs.h2 <- ggplot(plot.data, aes(x = med, y = term_plot, colour = model_clean)) +
  geom_vline(xintercept = 1, colour = "black", size = 0.5) +  
  geom_pointrangeh(aes(xmin = `5%`, xmax = `95%`), size = 0.5, fatten = 3) + 
  labs(x = "Percent change in ratio (odds ratio)", y = NULL) +
  scale_colour_manual(values = model.colors, name = "Models") +
  expand_limits(x = c(0.6, 1.3)) +
  guides(color = guide_legend(override.aes = list(size = 0.25))) +
  theme_donors() + 
  theme(legend.position = c(0.5, 0.02), legend.justification = c(0.15, 0),
        axis.title.x = element_text(hjust = 0)) +
  facet_wrap(~ coef.type, scales = "free", ncol = 2)
fig.coefs.h2

fig.save.cairo(fig.coefs.h2, filename = "fig-coefs-h2-bayes",
               width = 5.5, height = 3)
```

#### Complete results in a table

```{r h2-table, results="asis", warning=FALSE}
caption <- "The effect of anti-NGO legislation on the proportion of OECD overseas development assistance (ODA) committed to contentious purposes in the following year (H~2~), full models. Each cell contains the parameter's posterior median, the 95% credible interval, and the probability that the parameter is greater than one. {#tbl:h2-coefs}"
note <- c("Logit-linear models. Percent change odds ratios reported.")

table.h2 <- bayesgazer(mods.h2.next_year.bayes, exponentiate = TRUE,
                       caption = caption, note = note)

cat(table.h2)
cat(table.h2, file = here("Output", "tbl-h2-coefs-bayes.md"))
```

#### Complete results (nonimputed)

The models for H~2~ behave strangely sometimes (specifically the coefficient for adding a new advocacy regulation, which goes strongly in the opposite direction that we've hypothesized and that it goes in every single other model), so maybe it's an artifact of imputation? [Imputation isn't a panacea, after all](https://doi.org/10.1017/pan.2018.18), and in some cases it performs just as well as listwise deletion, so maybe this is a case of that?

lolnope ¯\\\_(ツ)\_/¯

```{r h2-no-imputation, message=FALSE, warning=FALSE}
mods.h2.next_year.bayes.no.imp <- mods.h2.next_year.raw.bayes %>%
  filter(m == "original") %>% 
  gather(model.name, model, -m) %>%
  mutate(glance = model %>% map(glance),
         tidy = model %>% map(tidy)) %>% 
  mutate(model_exp = model %>% map(add_expmcmc))

h2_coefs <- mods.h2.next_year.bayes.no.imp %>%
  unnest(tidy) %>% 
  filter(!duplicated(term, fromLast = TRUE)) %>%
  mutate(term_join = str_replace(term, "TRUE", "")) %>% 
  left_join(coef.names.all, by = c("term_join" = "term")) %>% 
  filter(term != "(Intercept)")

h2_coefs_named <- h2_coefs %>% pull(term) %>% 
  set_names(h2_coefs$term_clean)

huxreg(mods.h2.next_year.bayes.no.imp$model_exp,
       coefs = c(h2_coefs_named, Constant = "(Intercept)"),
       stars = NULL,
       tidy_args = list(conf.int = TRUE, conf.level = 0.9),
       error_format = "({conf.low}, {conf.high})")
```

### Predicted proportion of contentious aid

```{r h2-predict-total, warning=FALSE, message=FALSE, cache=TRUE}
model <- mods.h2.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h2.barriers.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]

new.data <- get_all_vars(model$formula, data = model$data) %>%
  select(-c(barriers.total_within, year, cowcode)) %>%
  summarise_all(typical) %>%
  mutate(id = 1) %>%
  right_join(expand.grid(barriers.total_within = seq(-3, 4, 0.5),
                         cowcode = 1000:1049,
                         year = 1981:2012,
                         id = 1), by = "id") %>% select(-id)

predicted.h2.barriers.total <- new.data %>%
  nest(-cowcode) %>%
  mutate(predicted = future_map(.x = data, ~ generate_predictions(.x))) %>%
  unnest()

df.plot.data.h2 <- predicted.h2.barriers.total %>%
  group_by(cowcode, barriers.total_within) %>%
  summarise_at(vars(predicted), funs(mean(.))) %>%
  ungroup() %>% 
  mutate(value.fixed = inv.logit(predicted, a = 0.001))

df.plot.data.mean.h2 <- df.plot.data.h2 %>%
  group_by(barriers.total_within) %>%
  summarise(predicted = mean(predicted)) %>%
  mutate(value.fixed = inv.logit(predicted, a = 0.001)) %>%
  mutate(cowcode = 1)  # Fake country so the line plots
```

```{r h2-predict-individual, warning=FALSE, message=FALSE, cache=TRUE}
barriers.indiv.clean.names <- tribble(
  ~barrier, ~barrier.clean,
  "advocacy_within", "Barriers to advocacy",
  "entry_within", "Barriers to entry",
  "funding_within", "Barriers to funding"
)

model <- mods.h2.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h2.type.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]

hypothetical.bounds <- get_all_vars(model$formula, data = model$data) %>%
  select(advocacy_within, entry_within, funding_within) %>%
  summarise_all(funs(min, max)) %>%
  gather(key, value) %>%
  mutate(value = round(value, 0)) %>%
  # Have to separate on _m because of multiple _s, then re-add the m
  separate(key, into = c("term", "variable"), sep = "_m") %>%
  mutate(variable = paste0("m", variable)) %>%
  spread(variable, value)

new.data.hypothetical.nested <- hypothetical.bounds %>%
  nest(-term) %>%
  mutate(newdata = map2(.x = data, .y = term,
                        ~ expand.grid(term = seq(.x$min, .x$max, by = 0.5),
                                      cowcode = 1000:1049,
                                      year = 1981:2012,
                                      id = 1) %>%
                          # Rename the term column to the actual term name
                          magrittr::set_colnames(c(.y, colnames(.)[-1]))))

new.data.hypothetical <- as_tibble(bind_rows(new.data.hypothetical.nested$newdata)) %>%
  mutate_at(vars(contains("within")), funs(ifelse(is.na(.), 0, .)))

new.data <- get_all_vars(model$formula, data = model$data) %>%
  select(-c(advocacy_within, entry_within, funding_within, year, cowcode)) %>%
  summarise_all(typical) %>%
  mutate(id = 1) %>%
  right_join(new.data.hypothetical, by = "id") %>% select(-id)

predicted.h2.barriers.individual <- new.data %>%
  nest(-cowcode) %>%
  mutate(predicted = future_map(.x = data, ~ generate_predictions(.x))) %>%
  unnest()

df.plot.data.indiv.h2 <- predicted.h2.barriers.individual %>%
  gather(barrier, barrier.value, c(advocacy_within, entry_within, funding_within)) %>%
  group_by(cowcode, barrier.value, barrier) %>%
  summarise_at(vars(predicted), funs(mean(.))) %>%
  mutate(value.fixed = inv.logit(predicted, a = 0.001)) %>% 
  left_join(barriers.indiv.clean.names, by = "barrier")

df.plot.data.mean.indiv.h2 <- df.plot.data.indiv.h2 %>%
  group_by(barrier, barrier.value) %>%
  summarise(predicted = mean(predicted)) %>%
  mutate(cowcode = 1) %>%  # Fake country so the line plots
  mutate(value.fixed = inv.logit(predicted, a = 0.001)) %>% 
  left_join(barriers.indiv.clean.names, by = "barrier")
```

```{r h2-predict-both-plot, fig.width=5.5, fig.height=3.5}
# Combine the two plot data frames
df.plot.data.both.h2 <- df.plot.data.h2 %>%
  mutate(barrier = "barriers.total_within", barrier.clean = "Total barriers") %>%
  rename(barrier.value = barriers.total_within) %>%
  bind_rows(df.plot.data.indiv.h2) %>%
  mutate(barrier.clean = ordered(fct_inorder(barrier.clean)),
         highlight = ifelse(barrier.clean == "Total barriers", TRUE, FALSE))

df.plot.data.mean.both.h2 <- df.plot.data.mean.h2 %>%
  mutate(barrier = "barriers.total_within", barrier.clean = "Total barriers") %>%
  rename(barrier.value = barriers.total_within) %>%
  bind_rows(df.plot.data.mean.indiv.h2) %>%
  mutate(barrier.clean = ordered(fct_inorder(barrier.clean)))

# Create data frame for highlighting the total panel
df.panel.highlight.h2 <- df.plot.data.both.h2 %>%
  distinct(barrier.clean, highlight)

fig.predicted.h2.barriers.both <- ggplot(df.plot.data.both.h2, 
                                         aes(x = barrier.value,
                                             y = value.fixed, group = cowcode)) + 
  geom_rect(data = df.panel.highlight.h2, aes(fill = highlight), inherit.aes = FALSE,
            xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf, alpha = 0.15) +
  geom_vline(xintercept = 0, colour = "black", size = 0.5) + 
  geom_smooth(method = "lm", size = 0.1, alpha = 0.1, colour = simulation.individual) +
  geom_smooth(data = df.plot.data.mean.both.h2, size = 1.5, 
              method = "lm", colour = simulation.mean) +
  labs(x = "Difference from average level of NGO legislation in country (within effect)",
       y = "Predicted proportion of\ncontentious aid in the following year") +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  scale_fill_manual(values = c(NA, "grey50"), guide = FALSE) +
  facet_wrap(~ barrier.clean, scales = "free_x") +
  theme_donors() + 
  theme(axis.title.x = element_text(hjust = 0))
fig.predicted.h2.barriers.both

fig.save.cairo(fig.predicted.h2.barriers.both, filename = "fig-predicted-h2",
               width = 5.5, height = 3.5)
```


---

## H~3~: Donors shift aid to international NGOs

> **H~3~**: As restrictive laws against local NGOs increase, states should be more likely to provide aid to INGOs rather than local NGOs.

We use two dependent variables for this hypothesis: the proportion of aid channeled through either (1) domestic or (2) international or US-based (or foreign) NGOs, once again leaded by one year. The OECD and AidData do not track the channels of aid delivery, so we cannot see how aid is distributed on a global scale. USAID, however, does track channels, so we can measure how much aid goes to domestic NGOs (and also US-based and international NGOs). USAID didn't start tracking this until 2001, though, so we have to limit our models to 2001–2013. (Boo.)

It would be cool to model the ratio aid channeled through domestic to foreign NGOs, but doing that causes weird mathematical issues with logit transformations, since the ratios can exceed 1. 

Because the DVs are proportions, we have to make the same assumptions and weird interpretive tricks as H~2~, building a logit-linear model of the ratio of domestic or foreign NGO aid to all other channels:

$$ln( \frac{\text{Aid to (domestic or foreign) NGOs}_{\text{USAID}}}{\text{Aid to other channels}_{\text{USAID}}} )_{i, t+1} = \text{NGO legislation}_{it} + \text{controls}_{it}$$

Again, we use the same NGO legislation variables as H~1~ and H~2~ and use the same controls, except we omit "After 1989" since no observations actually occur after 1989.

```{r h3-models-bayes-domestic, warning=FALSE, message=FALSE}
# Get model details and parameters
mods.h3.dom.next_year.bayes <- mods.h3.dom.next_year.raw %>%
  gather(model.name, model, -m) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy),
         augment = model %>% map(broom::augment)) %>%
  filter(m != "original")
```

```{r h3-models-bayes-foreign, warning=FALSE, message=FALSE}
# Get model details and parameters
mods.h3.foreign.next_year.bayes <- mods.h3.foreign.next_year.raw %>%
  gather(model.name, model, -m) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy),
         augment = model %>% map(broom::augment)) %>%
  filter(m != "original")
```

### MCMC diagnostics {.tabset .tabset-fade .tabset-pills}

#### Check fit

Again, use one of the imputed models (`mod.h3.barriers.total`) to check for fit and convergence.

```{r h3-diagnostics-bayes}
model.to.check <- mods.h3.dom.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h3.barriers.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]
```

Posterior predictive distribution vs. observed outcome?

```{r h3-diag-density}
pp_check(model.to.check, plotfun = "ppc_dens_overlay", nreps = 5) + 
  theme_donors()
```

#### Check convergence

Chain convergence:

```{r h3-diag-divergence}
rstan::stan_diag(model.to.check, information = "divergence")
```


### Results {.tabset .tabset-fade .tabset-pills}

#### Proportion to domestic NGOs

```{r h3-table-domestic, results="asis", warning=FALSE}
caption <- "The effect of anti-NGO legislation on the proportion of US aid channeled through *domestic* NGOs in the following year (H~3~), full models. Each cell contains the parameter's posterior median, the 95% credible interval, and the probability that the parameter is greater than one {#tbl:h3-domestic-coefs}"
note <- c("Logit-linear models. Percent change odds ratios reported.")

table.h3.domestic <- bayesgazer(mods.h3.dom.next_year.bayes,
                                caption = caption, note = note, exponentiate = TRUE)

cat(table.h3.domestic)
cat(table.h3.domestic, file = here("Output", "tbl-h3-domestic-coefs-bayes.md"))
```

#### Proportion to foreign NGOs

```{r h3-table-foreign, results="asis", warning=FALSE}
caption <- "The effect of anti-NGO legislation on the proportion of US aid channeled through *US-based and international* NGOs in the following year (H~3~), full models. Each cell contains the parameter's posterior median, the 95% credible interval, and the probability that the parameter is greater than one {#tbl:h3-foreign-coefs}"
note <- c("Logit-linear models. Percent change odds ratios reported.")

table.h3.domestic <- bayesgazer(mods.h3.foreign.next_year.bayes,
                                caption = caption, note = note, exponentiate = TRUE)

cat(table.h3.domestic)
cat(table.h3.domestic, file = here("Output", "tbl-h3-foreign-coefs-bayes.md"))
```

#### Plot of proportion to domestic and foreign NGOs {.active}

```{r plot-h3-coefs-both, warning=FALSE, message=FALSE, fig.width=5.5, fig.height=4}
vars.to.plot <- c("barriers.total_within", "barriers.total_between",
                  "barriers.total_new",
                  "advocacy_within", "advocacy_between", 
                  "entry_within", "entry_between", 
                  "funding_within", "funding_between",
                  "advocacy_new", "entry_new", "funding_new",
                  "csre_within", "csre_between")

mods.h3.dom.melded <- bayes.meld(mods.h3.dom.next_year.bayes,
                                 vars.to.plot, exponentiate = TRUE)$melded.summary

coefs.raw.h3.dom <- mods.h3.dom.melded %>%
  left_join(coef.names.all, by = "term") %>%
  left_join(model.names, by = c("model.name" = "model")) %>% 
  mutate(term = factor(term, levels = vars.to.plot, ordered = TRUE)) %>%
  arrange(desc(term)) %>%
  mutate(term_plot = ordered(fct_inorder(term_plot_short))) %>%
  mutate(coef.type = case_when(
    str_detect(.$term, "_within") ~ "Within",
    str_detect(.$term, "_between") ~ "Between",
    TRUE ~ "Not split"
  )) %>% 
  mutate(coef.type = factor(coef.type, levels = c("Within", "Between", "Not split"),
                            ordered = TRUE)) %>%
  mutate(model_clean = factor(model_clean, levels = rev(unique(model_clean)), ordered = TRUE))

mods.h3.foreign.melded <- bayes.meld(mods.h3.foreign.next_year.bayes,
                                     vars.to.plot, exponentiate = TRUE)$melded.summary

coefs.raw.h3.foreign <- mods.h3.foreign.melded %>%
  left_join(coef.names.all, by = "term") %>%
  left_join(model.names, by = c("model.name" = "model")) %>% 
  mutate(term = factor(term, levels = vars.to.plot, ordered = TRUE)) %>%
  arrange(desc(term)) %>%
  mutate(term_plot = ordered(fct_inorder(term_plot_short))) %>%
  mutate(coef.type = case_when(
    str_detect(.$term, "_within") ~ "Within",
    str_detect(.$term, "_between") ~ "Between",
    TRUE ~ "Not split"
  )) %>% 
  mutate(coef.type = factor(coef.type, levels = c("Within", "Between", "Not split"),
                            ordered = TRUE)) %>%
  mutate(model_clean = factor(model_clean, levels = rev(unique(model_clean)), ordered = TRUE))

coefs.h3.both <- bind_rows(`Domestic NGOs` = coefs.raw.h3.dom,
                           `Foreign NGOs` = coefs.raw.h3.foreign,
                           .id = "channel")

fig.coefs.h3 <- ggplot(coefs.h3.both, aes(y = term_plot, x = med, 
                                          colour = model_clean)) + 
  geom_vline(xintercept = 1, colour = "black", size = 0.5) + 
  geom_pointrangeh(aes(xmin = `5%`, xmax = `95%`, shape = channel), 
                   size = 0.5, fatten = 3,
                   position = position_dodgev(height = 0.5)) + 
  labs(x = "Percent change in ratio (odds ratio)", y = NULL) +
  scale_colour_manual(values = model.colors) +
  expand_limits(x = c(0.5, 2)) +
  guides(color = guide_legend(override.aes = list(size = 0.25),
                              title = "Models"),
         shape = guide_legend(override.aes = list(size = 0.5, linetype = 0),
                              title = "Channel")) +
  theme_donors() + 
  theme(legend.position = c(0.5, -0.01), legend.justification = c(0.15, 0),
        axis.title.x = element_text(hjust = 0)) +
  facet_wrap(~ coef.type, scales = "free", ncol = 2)
fig.coefs.h3

fig.save.cairo(fig.coefs.h3, filename = "fig-coefs-h3-bayes",
               width = 5.5, height = 4)
```

#### Proportion to domestic NGOs (nonimputed)

```{r h3-domestic-no-imputation, message=FALSE, warning=FALSE}
mods.h3.dom.next_year.bayes.no.imp <- mods.h3.dom.next_year.raw %>%
  filter(m == "original") %>% 
  gather(model.name, model, -m) %>%
  mutate(glance = model %>% map(glance),
         tidy = model %>% map(tidy)) %>% 
  mutate(model_exp = model %>% map(add_expmcmc))

h3_dom_coefs <- mods.h3.dom.next_year.bayes.no.imp %>%
  unnest(tidy) %>% 
  filter(!duplicated(term, fromLast = TRUE)) %>%
  mutate(term_join = str_replace(term, "TRUE", "")) %>% 
  left_join(coef.names.all, by = c("term_join" = "term")) %>% 
  filter(term != "(Intercept)")

h3_dom_coefs_named <- h3_dom_coefs %>% pull(term) %>% 
  set_names(h3_dom_coefs$term_clean)

huxreg(mods.h3.dom.next_year.bayes.no.imp$model_exp,
       coefs = c(h3_dom_coefs_named, Constant = "(Intercept)"),
       stars = NULL,
       tidy_args = list(conf.int = TRUE, conf.level = 0.9),
       error_format = "({conf.low}, {conf.high})")
```

#### Proportion to foreign NGOs (nonimputed)

```{r h3-foreign-no-imputation, message=FALSE, warning=FALSE}
mods.h3.foreign.next_year.bayes.no.imp <- mods.h3.foreign.next_year.raw %>%
  filter(m == "original") %>% 
  gather(model.name, model, -m) %>%
  mutate(glance = model %>% map(glance),
         tidy = model %>% map(tidy)) %>% 
  mutate(model_exp = model %>% map(add_expmcmc))

h3_foreign_coefs <- mods.h3.foreign.next_year.bayes.no.imp %>%
  unnest(tidy) %>% 
  filter(!duplicated(term, fromLast = TRUE)) %>%
  mutate(term_join = str_replace(term, "TRUE", "")) %>% 
  left_join(coef.names.all, by = c("term_join" = "term")) %>% 
  filter(term != "(Intercept)")

h3_foreign_coefs_named <- h3_foreign_coefs %>% pull(term) %>% 
  set_names(h3_foreign_coefs$term_clean)

huxreg(mods.h3.foreign.next_year.bayes.no.imp$model_exp,
       coefs = c(h3_foreign_coefs_named, Constant = "(Intercept)"),
       stars = NULL,
       tidy_args = list(conf.int = TRUE, conf.level = 0.9, exponentiate = TRUE),
       error_format = "({conf.low}, {conf.high})")
```

### Predicted proportion of aid channeled to domestic or foreign NGOs

```{r h3-predict-total, warning=FALSE, message=FALSE, cache=TRUE}
model <- mods.h3.foreign.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h3.foreign.barriers.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]

new.data <- get_all_vars(model$formula, data = model$data) %>%
  select(-c(barriers.total_within, year, cowcode)) %>%
  summarise_all(typical) %>%
  mutate(id = 1) %>%
  right_join(expand.grid(barriers.total_within = seq(-3, 4, 0.5),
                         cowcode = 1000:1049,
                         year = 2000:2012,
                         id = 1), by = "id") %>% select(-id)

predicted.h3.foreign.barriers.total <- new.data %>%
  nest(-cowcode) %>%
  mutate(predicted = future_map(.x = data, ~ generate_predictions(.x))) %>%
  unnest() %>% 
  mutate(ngo_type = "Foreign NGOs")

model <- mods.h3.dom.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h3.barriers.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]

new.data <- get_all_vars(model$formula, data = model$data) %>%
  select(-c(barriers.total_within, year, cowcode)) %>%
  summarise_all(typical) %>%
  mutate(id = 1) %>%
  right_join(expand.grid(barriers.total_within = seq(-3, 4, 0.5),
                         cowcode = 1000:1049,
                         year = 2000:2012,
                         id = 1), by = "id") %>% select(-id)

predicted.h3.dom.barriers.total <- new.data %>%
  nest(-cowcode) %>%
  mutate(predicted = future_map(.x = data, ~ generate_predictions(.x))) %>%
  unnest() %>% 
  mutate(ngo_type = "Domestic NGOs")

df.plot.data.h3 <- bind_rows(predicted.h3.foreign.barriers.total,
                             predicted.h3.dom.barriers.total) %>%
  group_by(cowcode, ngo_type, barriers.total_within) %>%
  summarise_at(vars(predicted), funs(mean(.))) %>%
  ungroup() %>% 
  mutate(value.fixed = inv.logit(predicted, a = 0.001))

df.plot.data.mean.h3 <- df.plot.data.h3 %>%
  group_by(ngo_type, barriers.total_within) %>%
  summarise(predicted = mean(predicted)) %>%
  mutate(value.fixed = inv.logit(predicted, a = 0.001)) %>%
  mutate(cowcode = 1)  # Fake country so the line plots
```

```{r h3-predict-individual, warning=FALSE, message=FALSE, cache=TRUE}
barriers.indiv.clean.names <- tribble(
  ~barrier, ~barrier.clean,
  "advocacy_within", "Barriers to advocacy",
  "entry_within", "Barriers to entry",
  "funding_within", "Barriers to funding"
)

model <- mods.h3.foreign.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h3.foreign.type.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]

hypothetical.bounds <- get_all_vars(model$formula, data = model$data) %>%
  select(advocacy_within, entry_within, funding_within) %>%
  summarise_all(funs(min, max)) %>%
  gather(key, value) %>%
  mutate(value = round(value, 0)) %>%
  # Have to separate on _m because of multiple _s, then re-add the m
  separate(key, into = c("term", "variable"), sep = "_m") %>%
  mutate(variable = paste0("m", variable)) %>%
  spread(variable, value)

new.data.hypothetical.nested <- hypothetical.bounds %>%
  nest(-term) %>%
  mutate(newdata = map2(.x = data, .y = term,
                        ~ expand.grid(term = seq(.x$min, .x$max, by = 0.5),
                                      cowcode = 1000:1049,
                                      year = 2000:2012,
                                      id = 1) %>%
                          # Rename the term column to the actual term name
                          magrittr::set_colnames(c(.y, colnames(.)[-1]))))

new.data.hypothetical <- as_tibble(bind_rows(new.data.hypothetical.nested$newdata)) %>%
  mutate_at(vars(contains("within")), funs(ifelse(is.na(.), 0, .)))

# Foreign NGOs
new.data <- get_all_vars(model$formula, data = model$data) %>%
  select(-c(advocacy_within, entry_within, funding_within, year, cowcode)) %>%
  summarise_all(typical) %>%
  mutate(id = 1) %>%
  right_join(new.data.hypothetical, by = "id") %>% select(-id)

predicted.h3.foreign.barriers.individual <- new.data %>%
  nest(-cowcode) %>%
  mutate(predicted = future_map(.x = data, ~ generate_predictions(.x))) %>%
  unnest() %>% 
  mutate(ngo_type = "Foreign NGOs")

# Domestic NGOs
model <- mods.h3.dom.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h3.type.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]

new.data <- get_all_vars(model$formula, data = model$data) %>%
  select(-c(advocacy_within, entry_within, funding_within, year, cowcode)) %>%
  summarise_all(typical) %>%
  mutate(id = 1) %>%
  right_join(new.data.hypothetical, by = "id") %>% select(-id)

predicted.h3.dom.barriers.individual <- new.data %>%
  nest(-cowcode) %>%
  mutate(predicted = future_map(.x = data, ~ generate_predictions(.x))) %>%
  unnest() %>% 
  mutate(ngo_type = "Domestic NGOs")

df.plot.data.indiv.h3 <- bind_rows(predicted.h3.foreign.barriers.individual,
                                   predicted.h3.dom.barriers.individual) %>%
  gather(barrier, barrier.value, c(advocacy_within, entry_within, funding_within)) %>%
  group_by(cowcode, ngo_type, barrier.value, barrier) %>%
  summarise_at(vars(predicted), funs(mean(.))) %>%
  mutate(value.fixed = inv.logit(predicted, a = 0.001)) %>% 
  left_join(barriers.indiv.clean.names, by = "barrier")

df.plot.data.mean.indiv.h3 <- df.plot.data.indiv.h3 %>%
  group_by(ngo_type, barrier, barrier.value) %>%
  summarise(predicted = mean(predicted)) %>%
  mutate(cowcode = 1) %>%  # Fake country so the line plots
  mutate(value.fixed = inv.logit(predicted, a = 0.001)) %>% 
  left_join(barriers.indiv.clean.names, by = "barrier")
```

```{r h3-predict-both-plot, fig.width=5.5, fig.height=4}
# Combine the two plot data frames
df.plot.data.both.h3 <- df.plot.data.h3 %>%
  mutate(barrier = "barriers.total_within", barrier.clean = "Total barriers") %>%
  rename(barrier.value = barriers.total_within) %>%
  bind_rows(df.plot.data.indiv.h3) %>%
  mutate(barrier.clean = ordered(fct_inorder(barrier.clean)),
         highlight = ifelse(barrier.clean == "Total barriers", TRUE, FALSE)) %>% 
  mutate(ngo_type = recode(ngo_type,
                           `Domestic NGOs` = "Proportion channeled to domestic NGOs",
                           `Foreign NGOs` = "… to foreign NGOs"),
         ngo_type = fct_inorder(ngo_type, ordered = TRUE))

df.plot.data.mean.both.h3 <- df.plot.data.mean.h3 %>%
  mutate(barrier = "barriers.total_within", barrier.clean = "Total barriers") %>%
  rename(barrier.value = barriers.total_within) %>%
  bind_rows(df.plot.data.mean.indiv.h3) %>%
  mutate(barrier.clean = ordered(fct_inorder(barrier.clean))) %>% 
  ungroup() %>% 
  mutate(ngo_type = recode(ngo_type,
                           `Domestic NGOs` = "Proportion channeled to domestic NGOs",
                           `Foreign NGOs` = "… to foreign NGOs"),
         ngo_type = fct_inorder(ngo_type, ordered = TRUE))

# Create data frame for highlighting the total panel
df.panel.highlight.h3 <- df.plot.data.both.h3 %>%
  distinct(barrier.clean, highlight)

fig.predicted.h3.barriers.both <- 
  ggplot(df.plot.data.both.h3, 
         aes(x = barrier.value, y = value.fixed, color = ngo_type,
             group = interaction(ngo_type, cowcode))) + 
  geom_rect(data = df.panel.highlight.h3, aes(fill = highlight), inherit.aes = FALSE,
            xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf, alpha = 0.15) +
  geom_vline(xintercept = 0, colour = "black", size = 0.5) + 
  geom_smooth(method = "lm", size = 0.1, alpha = 0.1) +
  geom_smooth(data = df.plot.data.mean.both.h3, size = 1, method = "lm") +
  labs(x = "Difference from average level of NGO legislation in country (within effect)",
       y = "Predicted proportion of\naid channeled to type of NGO\nin the following year") +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  scale_fill_manual(values = c(NA, "grey50"), guide = FALSE) +
  scale_color_manual(values = c("grey60", "black"), name = NULL) + 
  facet_wrap(~ barrier.clean, scales = "free_x", ncol = 2) +
  theme_donors() + 
  theme(axis.title.x = element_text(hjust = 0),
        legend.justification = "left",
        legend.margin = margin(l = 0))
fig.predicted.h3.barriers.both

fig.save.cairo(fig.predicted.h3.barriers.both, filename = "fig-predicted-h3",
               width = 5.5, height = 4)
```
