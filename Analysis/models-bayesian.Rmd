---
title: "Bayesian models"
author: "Suparna Chaudhry and Andrew Heiss"
date: "`r format(Sys.time(), '%F')`"
output: 
  html_document: 
    code_folding: hide
    css: ../html/fixes.css
    fig_height: 3.5
    fig_width: 5
    highlight: pygments
    includes:
      after_body: ../html/add_home_link.html
    theme: spacelab
    toc: yes
    toc_depth: 4
    toc_float: yes
---


```{r echo=FALSE}
if (isTRUE(getOption('knitr.in.progress'))) {
  knitr::read_chunk(file.path(PROJHOME, "Analysis", "models-chunks.R"))
} else {
  source(file.path(PROJHOME, "Analysis", "models-chunks.R"))
}
```

```{r load-libraries, message=FALSE}
```

```{r load-data, cache=TRUE, message=FALSE}
```

```{r load-bayesian-models}
h1.raw <- file.path(PROJHOME, "Data", "data_cache", "models_bayes_h1.rds")
h2.raw <- file.path(PROJHOME, "Data", "data_cache", "models_bayes_h2.rds")
h3.domestic.raw <- file.path(PROJHOME, "Data", "data_cache", "models_bayes_h3_domestic.rds")
h3.foreign.raw <- file.path(PROJHOME, "Data", "data_cache", "models_bayes_h3_foreign.rds")

if (file.exists(h1.raw) & file.exists(h2.raw) & 
    file.exists(h3.domestic.raw) & file.exists(h3.foreign.raw)) {
  mods.h1.next_year.raw.bayes <- readRDS(h1.raw)
  mods.h2.next_year.raw.bayes <- readRDS(h2.raw)
  mods.h3.dom.next_year.raw <- readRDS(h3.domestic.raw)
  mods.h3.foreign.next_year.raw <- readRDS(h3.foreign.raw)
} else {
  stop("Run Data/run_bayes_remote.R to generate the model data")
}
```

```{r multidplyr}
# https://www.r-bloggers.com/speed-up-your-code-parallel-processing-with-multidplyr/
library(multidplyr)
cores <- parallel::detectCores()
# parallel::stopCluster(cluster)
```

```{r helpful-functions}
```

---

## H~1~: Donors reduce aid in response to legislation

> **H~1~**: In response to restrictive NGO legislation, bilateral, multilateral, and private donors may reduce their aid to repressive countries.

$$ln( \text{ODA}_{\text{OECD}} )_{i, t+1} = \text{NGO legislation}_{it} + \text{controls}_{it}$$

Our dependent variable for this hypothesis is the log of ODA (constant 2011 dollars), leaded by one year so we don't have to lag every other independent variable. As a robustness check, we also include models with log ODA leaded by 2 years and 5 years to account the implementation period following the passage of a law.

We look at NGO legislation in a few different ways:

- `barriers.total`: Number of anti-NGO legal barriers in a country-year
- `barriers.total_new`: Indicator marking if a new anti-NGO barrier was passed in a country year
- `advocacy + entry + funding`: Number of anti-NGO legal barriers by type of barrier
- `advocacy_new + entry_new + funding_new`: Indicators marking new type of barrier
- `csre`: Civil society regulatory environment index (CSRE), ranging from roughly -4 to 4 (higher values = better civil society regulations)

```{r h1-models-bayes-1, warning=FALSE, message=FALSE}
# Get model details and parameters
mods.h1.next_year.bayes <- mods.h1.next_year.raw.bayes %>%
  gather(model.name, model, -m) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy, intervals=TRUE, prob=0.95),
         augment = model %>% map(broom::augment)) %>%
  filter(m != "original")
```


### MCMC diagnostics

We use one of the imputed models (`mod.h1.barriers.total`) to check for fit and convergence.

```{r h1-diagnostics-bayes}
model.to.check <- mods.h1.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h1.barriers.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]
```

How well does the posterior predictive distribution fit the observed outcome? Not great, but not perfectly. The actual distribution is bimodal, with a bunch of zeros, and the model gets the two peaks, but they're shallow. We can live with it, though.

```{r h1-diag-density}
pp_check(model.to.check, plotfun="ppc_dens_overlay", nreps=5) + 
  theme_donors()
```

What about chain convergence? These should look like tops if everything converges, with no observations at 0 in the mean Metropolis-Hastings aceptance panel.

```{r h1-diag-divergence}
rstan::stan_diag(model.to.check, information="divergence")
```


### Merging MCMC chains

Merging the MCMC chains is relatively easy, but then working with the 20,000 rows of simulations is trickier, since merging makes the model a `data_frame` intead of a `stanreg` object, meaning all the convenience funcions like `posterior_predict()` don't work anymore. That means lots of math. Ugh.

So instead, we do two things. We calculate the posterior median and MD by just merging all the MCMC chains from all imputations. Becuase `posterior_predict()` doesn't work on merged chains like this, we run `posterior_predict()` on each imputation and then take the mean of each imputation's credible intervals. This should be okay—taking the median of medians (or [mean of means](http://stats.stackexchange.com/q/133138/3025)) will yield the same value if the group sizes are the same (thus avoiding Simpson's Paradox). Like this:

```{r median-of-medians}
group1 = c(1, 2, 3, 4)
group2 = c(5, 6, 7, 8)

median(c(group1, group2))
median(c(median(group1), median(group2)))
```

If it's a little off, it should be okay—it'll be off by an order of 0.001ish. 


### Results

```{r h1-plot-coefs, fig.width=7, fig.height=4}
vars.to.plot <- c("barriers.total_within", "barriers.total_between",
                  "barriers.total_new",
                  "advocacy_within", "advocacy_between", 
                  "entry_within", "entry_between", 
                  "funding_within", "funding_between",
                  "advocacy_new", "entry_new", "funding_new",
                  "csre_within", "csre_between")

mods.h1.melded <- bayes.meld(mods.h1.next_year.bayes,
                             vars.to.plot)$melded.summary

plot.data <- mods.h1.melded %>%
  left_join(coef.names.all, by="term") %>%
  mutate(term = factor(term, levels=vars.to.plot, ordered=TRUE)) %>%
  arrange(desc(term)) %>%
  mutate(term_plot = ordered(fct_inorder(term_plot))) %>%
  mutate(coef.type = case_when(
    str_detect(.$term, "_within") ~ "Within",
    str_detect(.$term, "_between") ~ "Between",
    TRUE ~ "Not split"
  )) %>% 
  mutate(coef.type = factor(coef.type, levels=c("Within", "Between", "Not split"),
                            ordered=TRUE)) %>%
  mutate(model.name = factor(model.name, levels=rev(unique(model.name)), ordered=TRUE))

fig.coefs.h1 <- ggplot(plot.data, aes(x=med, y=term_plot, 
                                      xmin=`2.5%`, xmax=`97.5%`, colour=model.name)) +
  geom_vline(xintercept=0) +
  geom_pointrangeh() +
  labs(x="Posterior median change in log ODA in following year", y=NULL) +
  scale_colour_manual(values=model.colors) +
  guides(color=FALSE) +
  theme_donors() + theme(axis.text.x=element_text(angle=45, hjust=1)) +
  facet_wrap(~ coef.type, scales="free")
fig.coefs.h1

fig.save.cairo(fig.coefs.h1, filename="fig-coefs-h1-bayes",
               width=7, height=2.5)
```

```{r h1-table, results="asis", warning=FALSE}
caption <- "The effect of anti-NGO legislation on OECD overseas development assistance (ODA) in the following year (H~1~), full models. Each cell contains the parameter's posterior median, the 95% credible interval, and the probability that the parameter is greater than zero. {#tbl:h1-coefs}"
note <- c("Dependent variable log transformed.")
table.h1 <- bayesgazer(mods.h1.next_year.bayes,
                       caption=caption, note=note)

cat(table.h1)
cat(table.h1, file=file.path(PROJHOME, "Output",
                             "tbl-h1-coefs-bayes.md"))
```


### Model diagnostics

Country intercepts vary with an SD of 0.07 (etc.), year intercepts vary with an SD of 0.07 (etc.), and the SD of error not accounted for by either within-country or within-year variability is 3.02 (etc.)


### Predicted ODA

Here, for the sake of computational efficiency and speed, we only use one of the imputed datasets for predictions. Technically we should base the predictions on all the merged chains, but (1) there's no function that can handle that, (2) it would take forever to run predictions on each individual imputation and then combine the predictions, and (3) these are posterior medians anyway from ostensibly the same-ish distribution—quintupling the number of chains to simulate is overkill for drawing a picture.

```{r h1-predict-total, warning=FALSE, message=FALSE}
model <- mods.h1.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h1.barriers.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]

# For whatever reason, stanreg objects return the full data frame used in the
# model, not just the model matrix, when calling object$data. model.frame()
# chokes on object$formula because of (1 | x) grouping terms, but
# get_all_vars() works.
new.data <- get_all_vars(model$formula, data=model$data) %>%
  select(-c(barriers.total_within, year, cowcode)) %>%
    summarise_all(typical) %>%
    mutate(id = 1) %>%
    right_join(expand.grid(barriers.total_within = seq(-3, 4, 0.5),
                           cowcode = 1000:1049,
                           year = 1981:2012,
                           id = 1), by="id") %>% select(-id)

cluster <- create_cluster(cores=cores)

predicted.h1.barriers.total <- new.data %>%
  nest(-cowcode) %>%
  partition(cowcode, cluster=cluster) %>%
  cluster_library("tidyverse") %>%
  cluster_assign_value("model", model) %>%
  cluster_assign_value("generate_predictions", generate_predictions) %>%
  mutate(predicted = map(.x=data, ~ generate_predictions(.x))) %>%
  collect() %>%
  unnest()

df.plot.data <- predicted.h1.barriers.total %>%
  group_by(cowcode, barriers.total_within) %>%
  summarise_at(vars(predicted), funs(mean(.))) %>%
  ungroup()

df.plot.data.mean <- df.plot.data %>%
  group_by(barriers.total_within) %>%
  summarise(predicted = mean(predicted)) %>%
  mutate(cowcode=1)  # Fake country so the line plots
```

```{r h1-predict-individual, warning=FALSE, message=FALSE}
barriers.indiv.clean.names <- tribble(
  ~barrier, ~barrier.clean,
  "advocacy_within", "Barriers to advocacy",
  "entry_within", "Barriers to entry",
  "funding_within", "Barriers to funding"
)

model <- mods.h1.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h1.type.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]

hypothetical.bounds <- get_all_vars(model$formula, data=model$data) %>%
    select(advocacy_within, entry_within, funding_within) %>%
    summarise_all(funs(min, max)) %>%
    gather(key, value) %>%
    mutate(value = round(value, 0)) %>%
    # Have to separate on _m because of multiple _s, then re-add the m
    separate(key, into=c("term", "variable"), sep="_m") %>%
    mutate(variable = paste0("m", variable)) %>%
    spread(variable, value)

new.data.hypothetical.nested <- hypothetical.bounds %>%
    nest(-term) %>%
    mutate(newdata = map2(.x=data, .y=term,
                          ~ expand.grid(term = seq(.x$min, .x$max, by=0.5),
                                        cowcode = 1000:1049,
                                        year = 1981:2012,
                                        id = 1) %>%
                            # Rename the term column to the actual term name
                            magrittr::set_colnames(c(.y, colnames(.)[-1]))))
  
new.data.hypothetical <- as_tibble(bind_rows(new.data.hypothetical.nested$newdata)) %>%
  mutate_at(vars(contains("within")), funs(ifelse(is.na(.), 0, .)))
  
new.data <- get_all_vars(model$formula, data=model$data) %>%
  select(-c(advocacy_within, entry_within, funding_within, year, cowcode)) %>%
  summarise_all(typical) %>%
  mutate(id = 1) %>%
  right_join(new.data.hypothetical, by="id") %>% select(-id)

cluster <- create_cluster(cores=cores)

predicted.h1.barriers.individual <- new.data %>%
  nest(-cowcode) %>%
  partition(cowcode, cluster=cluster) %>%
  cluster_library("tidyverse") %>%
  cluster_assign_value("model", model) %>%
  cluster_assign_value("generate_predictions", generate_predictions) %>%
  mutate(predicted = map(.x=data, ~ generate_predictions(.x))) %>%
  collect() %>%
  unnest()

df.plot.data.indiv <- predicted.h1.barriers.individual %>%
  gather(barrier, barrier.value, c(advocacy_within, entry_within, funding_within)) %>%
  group_by(cowcode, barrier.value, barrier) %>%
  summarise_at(vars(predicted), funs(mean(.))) %>%
  left_join(barriers.indiv.clean.names, by="barrier")

df.plot.data.mean.indiv <- df.plot.data.indiv %>%
  group_by(barrier, barrier.value) %>%
  summarise(predicted = mean(predicted)) %>%
  mutate(cowcode=1) %>%  # Fake country so the line plots
  left_join(barriers.indiv.clean.names, by="barrier")
```

```{r h1-predict-both, warning=FALSE, fig.width=6.5, fig.height=4}
# Combine the two plot data frames
df.plot.data.both <- df.plot.data %>%
  mutate(barrier = "barriers.total_within", barrier.clean = "Total barriers") %>%
  rename(barrier.value = barriers.total_within) %>%
  bind_rows(df.plot.data.indiv) %>%
  mutate(barrier.clean = ordered(fct_inorder(barrier.clean)),
         highlight = ifelse(barrier.clean == "Total barriers", TRUE, FALSE))

df.plot.data.mean.both <- df.plot.data.mean %>%
  mutate(barrier = "barriers.total_within", barrier.clean = "Total barriers") %>%
  rename(barrier.value = barriers.total_within) %>%
  bind_rows(df.plot.data.mean.indiv) %>%
  mutate(barrier.clean = ordered(fct_inorder(barrier.clean)))

# Create data frame for highlighting the total panel
df.panel.highlight <- df.plot.data.both %>%
  distinct(barrier.clean, highlight)

fig.predicted.h1.barriers.both <- ggplot(df.plot.data.both, 
                                         aes(x=barrier.value, y=expm1(predicted), 
                                             group=cowcode)) + 
  geom_rect(data=df.panel.highlight, 
            aes(fill=highlight, x=NULL, y=NULL, group=NULL),
            xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf, alpha=0.15) +
  geom_vline(xintercept=0, size=0.5) +
  geom_smooth(method="lm", size=0.1, alpha=0.1, colour=simulation.individual) +
  geom_smooth(data=df.plot.data.mean.both, size=1.5, method="lm", colour=simulation.mean) +
  labs(x="Difference from average number of anti-NGO barriers in country\n(within effects)",
       y="Predicted ODA in the following year") +
  scale_y_continuous(labels=scales::dollar, trans=scales::log1p_trans()) +
  scale_fill_manual(values=c(NA, "grey50"), guide=FALSE) +
  facet_wrap(~ barrier.clean, scales="free_x") +
  theme_donors()

fig.display.both <- fig.predicted.h1.barriers.both + 
  labs(title="Donors reduce aid more in response to\nadditional advocacy-focused anti-NGO laws",
       subtitle="Predicted foreign aid (ODA) across range of differences from the average number of\nanti-NGO laws in a hypothetical average country; dark line shows average of\n500 draws from posterior distribution",
       caption="Chaudhry and Heiss (2017)") + 
  theme_donors(11)

fig.predicted.h1.barriers.both

fig.save.cairo(fig.predicted.h1.barriers.both, filename="fig-predicted-h1",
               width=6.5, height=4)
```


---

## H~2~: Donors shift aid to tamer causes

> **H~2~**: As restrictive laws against NGOs are enacted, donors start increasing funds for 'tamer' causes, and decreasing funds for politically sensitive causes.

Our dependent variable for this hypothesis is the percentage of ODA (still in constant 2011 dollars) allocated for contentious purposes, again leaded by one year. We classify contentious aid as any project focused on government and civil society (DAC codes 150 and 151) or conflict prevention and resolution, peace and security (DAC code 152).

Working with proportion data, however, poses interesting mathematical and methodological challenges, since the range of possible outcomes is limited to a value between 0 and 1. Treating proportion variables in a mixed model is technically possible, but it yields predicitions that go beyond the allowable range of values (1.13, -0.5, etc.). Treating the proportion as a binomial variable is also possible and is indeed [one of the ways to use the `glm()` function](http://stackoverflow.com/a/9111904/120898) in R. However, this entails considering the proportion as a ratio of success and failures. In this case, treating a dollar of contentious aid as a success feels off, especially since aid amounts aren't independence events—it's not like each dollar of aid goes through a probabalistic process likek a coin flip. Another solution is to use [beta regression](https://cran.r-project.org/package=betareg), which [constrains the outcome variable to values between 0 and 1](http://www.theanalysisfactor.com/zero-one-inflated-beta-models-for-proportion-data/), but unfortunately does not allow for values of exactly 0 or 1. Zero-and-one inflated beta regression models make adjustments for this, but [they aren't very popular](https://CRAN.R-project.org/package=zoib) and definitely don't accont for random effects and mixed models. 

[One recommendation by Ben Bolker](https://stat.ethz.ch/pipermail/r-sig-mixed-models/2011q1/015422.html), the maintainer of [`lme4`](https://cran.r-project.org/package=lme4), is to use a logit transformation of the dependent variable in `lmer()` models. This seems to be [standard practice in political science research](https://acrowinghen.com/2014/04/24/interpreting-coefficients-from-a-logit-linear-model-with-a-proportional-dependent-variable/), too. Logit transformations still can't handle values of exactly 0 or 1, though, so we [winsorize](https://en.wikipedia.org/wiki/Winsorizing) those values by adding or subtracting 0.001 to the extremes.

We thus use a logit-linear model of the ratio of contentious aid to non-contentious aid:

$$ln( \frac{\text{contentious ODA}_{\text{OECD}}}{\text{noncontentious ODA}_{\text{OECD}}} )_{i, t+1} = \text{NGO legislation}_{it} + \text{controls}_{it}$$

We look at NGO legislation in the same ways as H~1~ and use the same controls.

```{r h2-models-bayes, warning=FALSE, message=FALSE}
# Get model details and parameters
mods.h2.next_year.bayes <- mods.h2.next_year.raw.bayes %>%
  gather(model.name, model, -m) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy, intervals=TRUE, prob=0.95),
         augment = model %>% map(broom::augment)) %>%
  filter(m != "original")
```


### MCMC diagnostics

Again, use one of the imputed models (`mod.h2.barriers.total`) to check for fit and convergence.

```{r h2-diagnostics-bayes}
model.to.check <- mods.h2.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h2.barriers.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]
```

Posterior predictive distribution vs. observed outcome?

```{r h2-diag-density}
pp_check(model.to.check, plotfun="ppc_dens_overlay", nreps=5) + 
  theme_donors()
```

Chain convergence:

```{r h2-diag-divergence}
rstan::stan_diag(model.to.check, information="divergence")
```


### Results

```{r h2-plot-coefs, fig.width=7, fig.height=4}
vars.to.plot <- c("barriers.total_within", "barriers.total_between",
                  "barriers.total_new",
                  "advocacy_within", "advocacy_between", 
                  "entry_within", "entry_between", 
                  "funding_within", "funding_between",
                  "advocacy_new", "entry_new", "funding_new",
                  "csre_within", "csre_between")

mods.h2.melded <- bayes.meld(mods.h2.next_year.bayes,
                             vars.to.plot, exponentiate=TRUE)$melded.summary

plot.data <- mods.h2.melded %>%
  left_join(coef.names.all, by="term") %>%
  mutate(term = factor(term, levels=vars.to.plot, ordered=TRUE)) %>%
  arrange(desc(term)) %>%
  mutate(term_plot = ordered(fct_inorder(term_plot))) %>%
  mutate(coef.type = case_when(
    str_detect(.$term, "_within") ~ "Within",
    str_detect(.$term, "_between") ~ "Between",
    TRUE ~ "Not split"
  )) %>% 
  mutate(coef.type = factor(coef.type, levels=c("Within", "Between", "Not split"),
                            ordered=TRUE)) %>%
  mutate(model.name = factor(model.name, levels=rev(unique(model.name)), ordered=TRUE))

fig.coefs.h2 <- ggplot(plot.data, aes(x=med, y=term_plot, colour=model.name)) +
  geom_vline(xintercept=1, colour="grey50", size=0.5) + 
  geom_pointrangeh(aes(xmin=`2.5%`, xmax=`97.5%`), size=0.5) + 
  labs(x="Odds ratio", y=NULL) +
  scale_colour_manual(values=model.colors) +
  guides(color=FALSE) +
  theme_donors() + 
  facet_wrap(~ coef.type, scales="free")
fig.coefs.h2

fig.save.cairo(fig.coefs.h2, filename="fig-coefs-h2-bayes",
               width=7, height=2.5)
```

```{r h2-table, results="asis", warning=FALSE}
caption <- "The effect of anti-NGO legislation on the proportion of OECD overseas development assistance (ODA) committed to contentious purposes in the following year (H~2~), full models. Each cell contains the parameter's posterior median, the 95% credible interval, and the probability that the parameter is greater than one. {#tbl:h2-coefs}"
note <- c("Logit-linear models. Odds ratios reported.")

table.h2 <- bayesgazer(mods.h2.next_year.bayes, exponentiate=TRUE,
                       caption=caption, note=note)

cat(table.h2)
cat(table.h2, file=file.path(PROJHOME, "Output",
                             "tbl-h2-coefs-bayes.md"))
```


### Model diagnostics

### Predicted proportion of contentious aid

```{r h2-predict-both, warning=FALSE, message=FALSE, fig.width=6.5, fig.height=4}
# Barriers to advocacy
model <- mods.h2.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h2.type.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]

new.data <- get_all_vars(model$formula, data=model$data) %>%
  select(-c(advocacy_within, year, cowcode)) %>%
    summarise_all(typical) %>%
    mutate(id = 1) %>%
    right_join(expand.grid(advocacy_within = seq(-1, 2, 0.5),
                           cowcode = 1000:1049,
                           year = 1981:2012,
                           id = 1), by="id") %>% select(-id)

cluster <- create_cluster(cores=cores)

predicted.h2.advocacy <- new.data %>%
  nest(-cowcode) %>%
  partition(cowcode, cluster=cluster) %>%
  cluster_library("tidyverse") %>%
  cluster_assign_value("model", model) %>%
  cluster_assign_value("generate_predictions", generate_predictions) %>%
  mutate(predicted = map(.x=data, ~ generate_predictions(.x))) %>%
  collect() %>%
  unnest()

# CSRE
model <- mods.h2.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h2.csre") %>%
  select(model) %>% .[[1]] %>% .[[1]]

new.data <- get_all_vars(model$formula, data=model$data) %>%
  select(-c(csre_within, year, cowcode)) %>%
    summarise_all(typical) %>%
    mutate(id = 1) %>%
    right_join(expand.grid(csre_within = seq(-5, 5, 0.5),
                           cowcode = 1000:1049,
                           year = 1981:2012,
                           id = 1), by="id") %>% select(-id)

cluster <- create_cluster(cores=cores)

predicted.h2.csre <- new.data %>%
  nest(-cowcode) %>%
  partition(cowcode, cluster=cluster) %>%
  cluster_library("tidyverse") %>%
  cluster_assign_value("model", model) %>%
  cluster_assign_value("generate_predictions", generate_predictions) %>%
  mutate(predicted = map(.x=data, ~ generate_predictions(.x))) %>%
  collect() %>%
  unnest()

# Combine predictions into plottable data
df.plot.h2.advocacy <- predicted.h2.advocacy %>%
  group_by(cowcode, advocacy_within) %>%
  summarise_at(vars(predicted), funs(mean(.))) %>%
  ungroup() %>%
  mutate(value.fixed = inv.logit(predicted, a=0.001),
         variable.clean = "Barriers to advocacy") %>%
  rename(variable = advocacy_within)

df.plot.h2.csre <- predicted.h2.csre %>%
  group_by(cowcode, csre_within) %>%
  summarise_at(vars(predicted), funs(mean(.))) %>%
  ungroup() %>%
  mutate(value.fixed = inv.logit(predicted, a=0.001),
         variable.clean = "Civil society regulatory environment") %>%
  rename(variable = csre_within)

df.plot.data <- bind_rows(df.plot.h2.advocacy, df.plot.h2.csre)

df.plot.data.mean <- df.plot.data %>%
  group_by(variable.clean, variable) %>%
  summarise(predicted = mean(predicted)) %>%
  mutate(value.fixed = inv.logit(predicted, a=0.001)) %>%
  mutate(cowcode=1)  # Fake country so the line plots

fig.predicted.h2.barriers <- ggplot(df.plot.data, aes(x=variable, 
                                                      y=value.fixed, group=cowcode)) + 
  geom_vline(xintercept=0, size=0.5) +
  geom_smooth(method="lm", size=0.1, alpha=0.1, colour=simulation.individual) +
  geom_smooth(data=df.plot.data.mean, size=1.5, method="lm", colour=simulation.mean) +
  labs(x="Difference from average level of NGO legislation in country\n(within effect)",
       y="Predicted proportion of\ncontentious aid in the following year") +
  scale_y_continuous(labels=scales::percent) +
  facet_wrap(~ variable.clean, scales="free_x") +
  theme_donors()
fig.predicted.h2.barriers

fig.save.cairo(fig.predicted.h2.barriers, filename="fig-predicted-h2",
               width=6.5, height=2.5)
```


---

## H~3~: Donors shift aid to international NGOs

> **H~3~**: As restrictive laws against local NGOs increase, states should be more likely to provide aid to INGOs rather than local NGOs.

We use two dependent variables for this hypothesis: the proportion of aid channeled through either (1) domestic or (2) international or US-based (or foreign) NGOs, once again leaded by one year. The OECD and AidData do not track the channels of aid delivery, so we cannot see how aid is distributed on a global scale. USAID, however, does track channels, so we can measure how much aid goes to domestic NGOs (and also US-based and international NGOs). USAID didn't start tracking this until 2001, though, so we have to limit our models to 2001–2013. (Boo.)

It would be cool to model the ratio aid channeled through domestic to foreign NGOs, but doing that causes weird mathematical issues with logit transformations, since the ratios can exceed 1. 

Because the DVs are proportions, we have to make the same assumptions and weird interpretive tricks as H~2~, building a logit-linear model of the ratio of domestic or foreign NGO aid to all other channels:

$$ln( \frac{\text{Aid to (domestic or foreign) NGOs}_{\text{USAID}}}{\text{Aid to other channels}_{\text{USAID}}} )_{i, t+1} = \text{NGO legislation}_{it} + \text{controls}_{it}$$

Again, we use the same NGO legislation variables as H~1~ and H~2~ and use the same controls, except we omit "After 1989" since no observations actually occur after 1989.

```{r h3-models-bayes-domestic, warning=FALSE, message=FALSE}
# Get model details and parameters
mods.h3.dom.next_year.bayes <- mods.h3.dom.next_year.raw %>%
  gather(model.name, model, -m) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy, intervals=TRUE, prob=0.95),
         augment = model %>% map(broom::augment)) %>%
  filter(m != "original")
```

```{r h3-models-bayes-foreign, warning=FALSE, message=FALSE}
# Get model details and parameters
mods.h3.foreign.next_year.bayes <- mods.h3.foreign.next_year.raw %>%
  gather(model.name, model, -m) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy, intervals=TRUE, prob=0.95),
         augment = model %>% map(broom::augment)) %>%
  filter(m != "original")
```

### MCMC diagnostics

Again, use one of the imputed models (`mod.h3.barriers.total`) to check for fit and convergence.

```{r h3-diagnostics-bayes}
model.to.check <- mods.h3.dom.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h3.barriers.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]
```

Posterior predictive distribution vs. observed outcome?

```{r h3-diag-density}
pp_check(model.to.check, plotfun="ppc_dens_overlay", nreps=5) + 
  theme_donors()
```

Chain convergence:

```{r h3-diag-divergence}
rstan::stan_diag(model.to.check, information="divergence")
```


### Results

#### Proportion to domestic NGOs

```{r h3-table-domestic, results="asis", warning=FALSE}
caption <- "The effect of anti-NGO legislation on the proportion of US aid channeled through *domestic* NGOs in the following year (H~3~), full models. Each cell contains the parameter's posterior median, the 95% credible interval, and the probability that the parameter is greater than one {#tbl:h3-domestic-coefs}"
note <- c("Logit-linear models. Odds ratios reported.")

table.h3.domestic <- bayesgazer(mods.h3.dom.next_year.bayes,
                                caption=caption, note=note, exponentiate=TRUE)

cat(table.h3.domestic)
cat(table.h3.domestic, file=file.path(PROJHOME, "Output",
                                      "tbl-h3-domestic-coefs-bayes.md"))
```

#### Proportion to foreign NGOs

```{r h3-table-foreign, results="asis", warning=FALSE}
caption <- "The effect of anti-NGO legislation on the proportion of US aid channeled through *US-based and international* NGOs in the following year (H~3~), full models. Each cell contains the parameter's posterior median, the 95% credible interval, and the probability that the parameter is greater than one {#tbl:h3-foreign-coefs}"
note <- c("Logit-linear models. Odds ratios reported.")

table.h3.domestic <- bayesgazer(mods.h3.foreign.next_year.bayes,
                                caption=caption, note=note, exponentiate=TRUE)

cat(table.h3.domestic)
cat(table.h3.domestic, file=file.path(PROJHOME, "Output",
                                      "tbl-h3-foreign-coefs-bayes.md"))
```

#### Both

```{r plot-h3-coefs-both, fig.width=7, fig.height=4}
vars.to.plot <- c("barriers.total_within", "barriers.total_between",
                  "barriers.total_new",
                  "advocacy_within", "advocacy_between", 
                  "entry_within", "entry_between", 
                  "funding_within", "funding_between",
                  "advocacy_new", "entry_new", "funding_new",
                  "csre_within", "csre_between")

mods.h3.dom.melded <- bayes.meld(mods.h3.dom.next_year.bayes,
                                 vars.to.plot, exponentiate=TRUE)$melded.summary

coefs.raw.h3.dom <- mods.h3.dom.melded %>%
  left_join(coef.names.all, by="term") %>%
  mutate(term = factor(term, levels=vars.to.plot, ordered=TRUE)) %>%
  arrange(desc(term)) %>%
  mutate(term_plot = ordered(fct_inorder(term_plot))) %>%
  mutate(coef.type = case_when(
    str_detect(.$term, "_within") ~ "Within",
    str_detect(.$term, "_between") ~ "Between",
    TRUE ~ "Not split"
  )) %>% 
  mutate(coef.type = factor(coef.type, levels=c("Within", "Between", "Not split"),
                            ordered=TRUE)) %>%
  mutate(model.name = factor(model.name, levels=rev(unique(model.name)), ordered=TRUE))

mods.h3.foreign.melded <- bayes.meld(mods.h3.foreign.next_year.bayes,
                                     vars.to.plot, exponentiate=TRUE)$melded.summary

coefs.raw.h3.foreign <- mods.h3.foreign.melded %>%
  left_join(coef.names.all, by="term") %>%
  mutate(term = factor(term, levels=vars.to.plot, ordered=TRUE)) %>%
  arrange(desc(term)) %>%
  mutate(term_plot = ordered(fct_inorder(term_plot))) %>%
  mutate(coef.type = case_when(
    str_detect(.$term, "_within") ~ "Within",
    str_detect(.$term, "_between") ~ "Between",
    TRUE ~ "Not split"
  )) %>% 
  mutate(coef.type = factor(coef.type, levels=c("Within", "Between", "Not split"),
                            ordered=TRUE)) %>%
  mutate(model.name = factor(model.name, levels=rev(unique(model.name)), ordered=TRUE))

coefs.h3.both <- bind_rows(`Domestic NGOs` = coefs.raw.h3.dom,
                           `Foreign NGOs` = coefs.raw.h3.foreign,
                           .id="channel")

fig.coefs.h3 <- ggplot(coefs.h3.both, aes(y=term_plot, x=med, 
                                          colour=interaction(model.name, channel))) + 
  geom_vline(xintercept=1, colour="grey50", size=1) + 
  geom_pointrangeh(aes(xmin=`2.5%`, xmax=`97.5%`, shape=channel), size=0.5,
                   position=position_dodgev(height=0.5)) + 
  labs(x="Odds ratio", y=NULL) +
  scale_colour_manual(values=c(model.colors, model.colors)) +
  guides(color=FALSE, shape=guide_legend(title=NULL, reverse=TRUE)) +
  theme_donors() +
  facet_wrap(~ coef.type, scales="free")
fig.coefs.h3

fig.save.cairo(fig.coefs.h3, filename="fig-coefs-h3-bayes",
               width=7, height=3)
```

### Model diagnostics


### Predicted proportion of aid channeled to domestic or foreign NGOs

```{r h3-predict-both, warning=FALSE, message=FALSE, fig.width=6.5, fig.height=4}
# Aid to foreign NGOs ~ barriers to funding
model <- mods.h3.foreign.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h3.foreign.type.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]

new.data <- get_all_vars(model$formula, data=model$data) %>%
  select(-c(funding_within, year, cowcode)) %>%
    summarise_all(typical) %>%
    mutate(id = 1) %>%
    right_join(expand.grid(funding_within = seq(-2, 3, 0.5),
                           cowcode = 1000:1049,
                           year = 1981:2012,
                           id = 1), by="id") %>% select(-id)

cluster <- create_cluster(cores=cores)

predicted.h3.foreign <- new.data %>%
  nest(-cowcode) %>%
  partition(cowcode, cluster=cluster) %>%
  cluster_library("tidyverse") %>%
  cluster_assign_value("model", model) %>%
  cluster_assign_value("generate_predictions", generate_predictions) %>%
  mutate(predicted = map(.x=data, ~ generate_predictions(.x))) %>%
  collect() %>%
  unnest()

# Aid to domestic NGOs ~ barriers to funding
model <- mods.h3.dom.next_year.bayes %>%
  filter(m == "imp1", model.name == "mod.h3.type.total") %>%
  select(model) %>% .[[1]] %>% .[[1]]

new.data <- get_all_vars(model$formula, data=model$data) %>%
  select(-c(funding_within, year, cowcode)) %>%
    summarise_all(typical) %>%
    mutate(id = 1) %>%
    right_join(expand.grid(funding_within = seq(-2, 3, 0.5),
                           cowcode = 1000:1049,
                           year = 1981:2012,
                           id = 1), by="id") %>% select(-id)

cluster <- create_cluster(cores=cores)

predicted.h3.domestic <- new.data %>%
  nest(-cowcode) %>%
  partition(cowcode, cluster=cluster) %>%
  cluster_library("tidyverse") %>%
  cluster_assign_value("model", model) %>%
  cluster_assign_value("generate_predictions", generate_predictions) %>%
  mutate(predicted = map(.x=data, ~ generate_predictions(.x))) %>%
  collect() %>%
  unnest()

# Combine predictions into plottable data
df.plot.h3.foreign <- predicted.h3.foreign %>%
  group_by(cowcode, funding_within) %>%
  summarise_at(vars(predicted), funs(mean(.))) %>%
  ungroup() %>%
  mutate(value.fixed = inv.logit(predicted, a=0.001),
         variable.clean = "Aid through foreign NGOs") %>%
  rename(variable = funding_within)

df.plot.h3.domestic <- predicted.h3.domestic %>%
  group_by(cowcode, funding_within) %>%
  summarise_at(vars(predicted), funs(mean(.))) %>%
  ungroup() %>%
  mutate(value.fixed = inv.logit(predicted, a=0.001),
         variable.clean = "Aid through domestic NGOs") %>%
  rename(variable = funding_within)

df.plot.data <- bind_rows(df.plot.h3.foreign, df.plot.h3.domestic)

df.plot.data.mean <- df.plot.data %>%
  group_by(variable.clean, variable) %>%
  summarise(predicted = mean(predicted)) %>%
  mutate(value.fixed = inv.logit(predicted, a=0.001)) %>%
  mutate(cowcode=1)  # Fake country so the line plots

fig.predicted.h3.barriers <- ggplot(df.plot.data, aes(x=variable, 
                                                      y=value.fixed, group=cowcode)) + 
  geom_vline(xintercept=0, size=0.5) +
  geom_smooth(method="lm", size=0.1, alpha=0.1, colour=simulation.individual) +
  geom_smooth(data=df.plot.data.mean, size=1.5, method="lm", colour=simulation.mean) +
  labs(x="Difference from average number of barriers to funding\n(within effect)",
       y="Predicted proportion of aid to\ntype of NGO in the following year") +
  scale_y_continuous(labels=scales::percent) +
  facet_wrap(~ variable.clean, scales="free_x") +
  theme_donors()
fig.predicted.h3.barriers

fig.save.cairo(fig.predicted.h3.barriers, filename="fig-predicted-h3",
               width=6.5, height=2.5)
```
