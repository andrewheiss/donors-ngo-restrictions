---
title: "Models"
author: "Suparna Chaudhry and Andrew Heiss"
date: "`r format(Sys.time(), '%B %e, %Y')`"
output: 
  html_document: 
    code_folding: hide
    css: ../html/fixes.css
    fig_height: 3.5
    fig_width: 5
    highlight: pygments
    includes:
      after_body: ../html/add_home_link.html
    theme: spacelab
    toc: yes
    toc_depth: 4
    toc_float: yes
---

```{r load-libraries, message=FALSE}
knitr::opts_chunk$set(cache=FALSE, fig.retina=2,
                      tidy.opts=list(width.cutoff=120),  # For code
                      options(width=120))  # For output

library(tidyverse)
library(stringr)
library(forcats)
library(stargazer)
library(lme4)
library(modelr)
library(broom)

source(file.path(PROJHOME, "lib", "graphics.R"))
source(file.path(PROJHOME, "lib", "pandoc.R"))
source(file.path(PROJHOME, "lib", "bayes.R"))

my.seed <- 1234
set.seed(my.seed)

run.rstan <- FALSE
```

```{r load-data, cache=TRUE, message=FALSE}
df.country.aid <- readRDS(file.path(PROJHOME, "Data", "data_clean",
                                "df_country_aid_no_imputation.rds"))

df.country.aid.impute <- readRDS(file.path(PROJHOME, "Data", "data_clean",
                                           "df_country_aid_imputation.rds"))

dcjw.questions.clean <- read_csv(file.path(PROJHOME, "Data", "data_clean",
                                           "dcjw_questions.csv"))
dcjw.responses.clean <- read_csv(file.path(PROJHOME, "Data", "data_clean",
                                           "dcjw_responses.csv"))

df.country.aid.both <- bind_rows(df.country.aid, df.country.aid.impute)

# All the missing values have been taken care of, but final years for leaded
# variables *are* still missing (i.e. there's no aid data for 2014, so
# total.oda_log_next_year will be NA in 2013). For this fancy random effects
# regression to work, the demeaned variables have to be based on the means of
# all rows included in the regression, so they can't include rows that are
# dropped because of missingness. This means we have to make separate demeaned
# datasets for *_after_2 and *_after_5, but ¯\_(ツ)_/¯
df.country.aid.demean.next_year.both <- df.country.aid.both %>%
  filter(!is.na(total.oda_log_next_year)) %>%
  group_by(m, cowcode) %>%
  mutate_at(vars(barriers.total, advocacy, entry, funding, 
                 polity, gdp.capita_log, gdp.capita, trade.pct.gdp, corruption, csre),
            funs(between = mean(., na.rm=TRUE),  # meaned
                 within = . - mean(., na.rm=TRUE))) %>%  # demeaned
  ungroup()

df.country.aid.demean.next_year <- 
  filter(df.country.aid.demean.next_year.both, m == "original")

df.country.aid.demean.next_year.impute <- 
  filter(df.country.aid.demean.next_year.both, m != "original")

# After 2 years
df.country.aid.demean.after_2.both <- df.country.aid.both %>%
  filter(!is.na(total.oda_log_after_2)) %>%
  group_by(m, cowcode) %>%
  mutate_at(vars(barriers.total, advocacy, entry, funding, 
                 polity, gdp.capita_log, gdp.capita, trade.pct.gdp, corruption, csre),
            funs(between = mean(., na.rm=TRUE),  # meaned
                 within = . - mean(., na.rm=TRUE))) %>%  # demeaned
  ungroup()

df.country.aid.demean.after_2 <- 
  filter(df.country.aid.demean.after_2.both, m == "original")

df.country.aid.demean.after_2.impute <- 
  filter(df.country.aid.demean.after_2.both, m != "original")

# After 5 years
df.country.aid.demean.after_5.both <- df.country.aid.both %>%
  filter(!is.na(total.oda_log_after_5)) %>%
  group_by(m, cowcode) %>%
  mutate_at(vars(barriers.total, advocacy, entry, funding, 
                 polity, gdp.capita_log, gdp.capita, trade.pct.gdp, corruption, csre),
            funs(between = mean(., na.rm=TRUE),  # meaned
                 within = . - mean(., na.rm=TRUE))) %>%  # demeaned
  ungroup()

df.country.aid.demean.after_5 <- 
  filter(df.country.aid.demean.after_5.both, m == "original")

df.country.aid.demean.after_5.impute <- 
  filter(df.country.aid.demean.after_5.both, m != "original")
```

```{r helpful-functions}
stars <- function(p) {
  out <- symnum(p, cutpoints=c(0, 0.01, 0.05, 0.1, 1),
                symbols=c("***", "**", "*", ""))
  as.character(out)
}

fixed.digits <- function(x, n=2) {
  formatC(x, digits=n, format="f")
}

# Take apart the pieces of a random effects formula and rebuild it
build.formula <- function(DV, IVs) {
  terms.all <- attr(terms(IVs), "term.labels")
  terms.fixed <- terms.all[!stringr::str_detect(terms.all, "\\|")]
  terms.rand <- sapply(findbars(formula(IVs)),function(x) paste0("(", deparse(x), ")"))
  
  reformulate(c(terms.fixed, terms.rand), response=DV)
}

# Meld a bunch of imputed models
meld.imputed.models <- function(model.data) {
  models.df <- model.data$glance[[1]]$df.residual
  
  models.tidy <- model.data %>%
    select(tidy) %>%
    unnest(.id="imputation") %>%
    filter(group == "fixed")
  
  just.estimates <- models.tidy %>% 
    select(imputation, term, estimate) %>%
    spread(term, estimate) %>%
    select(-imputation)
  
  just.ses <- models.tidy %>%
    select(imputation, term, std.error) %>%
    spread(term, std.error) %>%
    select(-imputation)
  
  melded <- Amelia::mi.meld(just.estimates, just.ses)
  
  melded.tidy <- as.data.frame(cbind(t(melded$q.mi), 
                                     t(melded$se.mi))) %>%
    mutate(term = rownames(.)) %>%
    select(term, estimate = V1, std.error = V2) %>%
    mutate(statistic = estimate / std.error,
           conf.low = estimate + std.error * qt(0.025, models.df),
           conf.high = estimate + std.error * qt(0.975, models.df),
           p.value = 2 * pt(abs(statistic), models.df, lower.tail=FALSE),
           stars = stars(p.value))  
  melded.tidy
}

# Expects a data frame with a column named tidy.melded and a row for model names
stargazer.fake <- function(df, term.labels, model.order) {
  top.coefs <- df %>%
    unnest(tidy.melded) %>%
    mutate(fancy = paste0(fixed.digits(estimate, 3),
                          stars, "\\ \n(",
                          fixed.digits(std.error, 3),
                          ")")) %>%
    select(model.name, term, fancy) %>%
    spread(model.name, fancy, fill="") %>%
    mutate(term = factor(term, levels=term.labels, ordered=TRUE)) %>%
    arrange(term) %>%
    mutate(term = as.character(term)) %>%
    select_(.dots = c("term", model.order))
  
  bottom.details <- df %>%
    mutate(n = data %>% map_int(~ nrow(.$model[[1]]@frame))) %>%
    select(model.name, n) %>%
    mutate(term = "Observations",
           n = scales::comma(n)) %>%
    spread(model.name, n) %>%
    rbind(c("Country random effects", rep("Yes", nrow(df)))) %>%
    rbind(c("Year random effects", rep("Yes", nrow(df))))
  
  nice.top.bottom <- bind_rows(top.coefs, bottom.details)
  
  colnames(nice.top.bottom) <- str_replace_all(colnames(nice.top.bottom), 
                                               "mod\\.h\\d\\.", "")
  
  # Grid layout because linebreaks in tables are hard
  pandoc.table(nice.top.bottom,
               style="grid", keep.line.breaks=TRUE)
}
```

## General model specifications and controls

We use a standard set of controls in each model ([explained in more detail here](../Data/get_merge_data.html#other_controls_and_alternative_hypotheses)):

- Democracy: `polity`
- Wealth: `gdp.capita_log` (logged so it's on the same scale as the other variables) 
- Government capacity: `corruption`
- Bad stuff: `internal.conflict.past.5` and `natural_disaster.occurrence`

Following [Bell and Jones (2015)](http://dx.doi.org/10.1017/psrm.2014.7), we use crossed random effects for country and year and use a combination of meaned and demeaned versions of each continuous variable to estimate both the within and between effects of each variable. 

$$ y_{i, t + 1} = \beta_0 + \beta_1 (x_{it} - \bar{x}_i) + \beta_2 \bar{x}_i + \ldots $$

This approach has multiple benefits. The coefficients for the demeaned variables are roughly equivalent to their corresponding coefficeints in a fixed effects model, but a fixed effects model assumes that the between effect (captured by the mean variables) is 0, which is not the case. A random effects model specified in this manner is more interpretable, as it clearly separates the within and between effects (again, within = demeaned, between = mean).

Here's proof of how it works in some simple models. Model 1 is a basic OLS with country fixed effects. Model 2 is a basic OLS with country random effects, but potentially misspecified, since the between and within effects are conflated. Model 3 is a basic OLS with country random effects specified with between (mean; $\bar{x}_i$) and within (demeaned; $x_{it} - \bar{x}_i$) coefficients. The demeaned/within coefficients in Model 3 are roughly the same as those in the fixed effects Model 1. However, they're not identical. This is because rows are dropped with listwise deletion when the regression is run, but the demeaned values were based on group means that included values that were dropped (e.g. all 2013 rows are dropped because of lags, but the group means included 2013).

When all missing data is taken care of, like in the imputed data, this isn't a problem and the coefficients in the standard fixed effects model are identical to the within coefficients in the demeaned random effects model. See Models 4, 5, and 6, which are based on one of the imputed datasets—the `barriers.total` coefficient in Model 4 is the same as the `barriers.total_within` coefficient in Model 6.

```{r fixed-random-example, results="asis"}
# Example models using original incorrectly demeaned data
mod.test.fe <- lm(total.oda_log_next_year ~ 
                    barriers.total + polity + gdp.capita_log + 
                    as.factor(cowcode),
                  data=df.country.aid.demean.next_year)

mod.test.re <- lmer(total.oda_log_next_year ~ 
                    barriers.total + polity + gdp.capita_log + 
                    (1 | cowcode),
                  data=df.country.aid.demean.next_year)

mod.test.re.fancy <- lmer(total.oda_log_next_year ~ 
                            barriers.total_between + barriers.total_within +
                            polity_between + polity_within + 
                            gdp.capita_log_between + gdp.capita_log_within +
                            (1 | cowcode),
                          data=df.country.aid.demean.next_year)

# Example models using correctly demeaned data from one of the imputations
mod.test.fe.imp <- lm(total.oda_log_next_year ~
                        barriers.total + polity + gdp.capita_log +
                        as.factor(cowcode),
                      data=filter(df.country.aid.demean.next_year.both, m == "imp1"))

mod.test.re.imp <- lmer(total.oda_log_next_year ~
                          barriers.total + polity + gdp.capita_log +
                          (1 | cowcode),
                        data=filter(df.country.aid.demean.next_year.both, m == "imp1"))

mod.test.re.fancy.imp <- lmer(total.oda_log_next_year ~
                                barriers.total_between + barriers.total_within +
                                polity_between + polity_within +
                                gdp.capita_log_between + gdp.capita_log_within +
                                (1 | cowcode),
                              data=filter(df.country.aid.demean.next_year.both, m == "imp1"))

stargazer(mod.test.fe, mod.test.re, mod.test.re.fancy,
          mod.test.fe.imp, mod.test.re.imp, mod.test.re.fancy.imp,
          type="html", omit="factor", 
          add.lines=list(c("Country effects", rep("Yes", 6))),
          keep.stat=c("n"))
```


## H~1~: Donors reduce aid in response to legislation

> **H~1~**: In response to restrictive NGO legislation, bilateral, multilateral, and private donors may reduce their aid to repressive countries.

$$ln( \text{ODA} )_{i, t+1} = \text{NGO legislation}_{it} + \text{controls}_{it}$$

Our dependent variable for this hypothesis is the log of ODA (constant 2011 dollars), leaded by one year so we don't have to lag every other independent variable. We also include models with log ODA leaded by 2 years and 5 years to account the implementation period following the passage of a law.

We look at NGO legislation in a few different ways:

- `barriers.total`: Number of anti-NGO legal barriers in a country-year
- `barriers.total_new`: Indicator marking if a new anti-NGO barrier was passed in a country year
- `advocacy + entry + funding`: Number of anti-NGO legal barriers by type of barrier
- `advocacy_new + entry_new + funding_new`: Indicators marking new type of barrier
- `csre`: Civil society regulatory environment index (CSRE), ranging from roughly -4 to 4 (higher values = better civil society regulations)

```{r h1-models-1, warning=FALSE, message=FALSE, cache=TRUE}
source(file.path(PROJHOME, "Analysis", "h1_model_definitions.R"))
# Run models on each of the datasets (original and imputed) and save in a big data frame
mods.h1.next_year.raw <- df.country.aid.demean.next_year.both %>%
  nest(-m) %>%
  mutate(mod.h1.barriers.total = data %>% map(mod.h1.barriers.total,
                                              "total.oda_log_next_year"),
         mod.h1.barriers.new = data %>% map(mod.h1.barriers.new,
                                            "total.oda_log_next_year"),
         mod.h1.type.total = data %>% map(mod.h1.type.total,
                                          "total.oda_log_next_year"),
         mod.h1.type.new = data %>% map(mod.h1.type.new,
                                        "total.oda_log_next_year"),
         mod.h1.csre = data %>% map(mod.h1.csre,
                                    "total.oda_log_next_year"))

# Get model details and parameters
mods.h1.next_year <- mods.h1.next_year.raw %>%
  gather(model.name, model, -m, -data) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy, conf.int=TRUE),
         augment = model %>% map(broom::augment))

# Meld the imputed models
mods.h1.next_year.melded <- mods.h1.next_year %>%
  filter(m != "original") %>%
  group_by(model.name) %>%
  nest() %>%
  mutate(tidy.melded = data %>% map(meld.imputed.models),
         n = data %>% map_int(~ nrow(.$model[[1]]@frame))) 
```

```{r h1-models-2, warning=FALSE, message=FALSE, cache=TRUE}
mods.h1.after_2.raw <- df.country.aid.demean.after_2.both %>%
  nest(-m) %>%
  mutate(mod.h1.barriers.total = data %>% map(mod.h1.barriers.total,
                                              "total.oda_log_next_year"),
         mod.h1.barriers.new = data %>% map(mod.h1.barriers.new,
                                            "total.oda_log_next_year"),
         mod.h1.type.total = data %>% map(mod.h1.type.total,
                                          "total.oda_log_next_year"),
         mod.h1.type.new = data %>% map(mod.h1.type.new,
                                        "total.oda_log_next_year"),
         mod.h1.csre = data %>% map(mod.h1.csre,
                                    "total.oda_log_next_year"))

# Get model details and parameters
mods.h1.after_2 <- mods.h1.after_2.raw %>%
  gather(model.name, model, -m, -data) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy, conf.int=TRUE),
         augment = model %>% map(broom::augment))

# Meld the imputed models
mods.h1.after_2.melded <- mods.h1.after_2 %>%
  filter(m != "original") %>%
  group_by(model.name) %>%
  nest() %>%
  mutate(tidy.melded = data %>% map(meld.imputed.models),
         n = data %>% map_int(~ nrow(.$model[[1]]@frame))) 
```

```{r h1-models-5, warning=FALSE, message=FALSE, cache=TRUE}
mods.h1.after_5.raw <- df.country.aid.demean.after_5.both %>%
  nest(-m) %>%
  mutate(mod.h1.barriers.total = data %>% map(mod.h1.barriers.total,
                                              "total.oda_log_next_year"),
         mod.h1.barriers.new = data %>% map(mod.h1.barriers.new,
                                            "total.oda_log_next_year"),
         mod.h1.type.total = data %>% map(mod.h1.type.total,
                                          "total.oda_log_next_year"),
         mod.h1.type.new = data %>% map(mod.h1.type.new,
                                        "total.oda_log_next_year"),
         mod.h1.csre = data %>% map(mod.h1.csre,
                                    "total.oda_log_next_year"))

# Get model details and parameters
mods.h1.after_5 <- mods.h1.after_5.raw %>%
  gather(model.name, model, -m, -data) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy, conf.int=TRUE),
         augment = model %>% map(broom::augment))

# Meld the imputed models
mods.h1.after_5.melded <- mods.h1.after_5 %>%
  filter(m != "original") %>%
  group_by(model.name) %>%
  nest() %>%
  mutate(tidy.melded = data %>% map(meld.imputed.models),
         n = data %>% map_int(~ nrow(.$model[[1]]@frame))) 
```

```{r h1-models-bayes-1, warning=FALSE, message=FALSE}
if (run.rstan) {
  source(file.path(PROJHOME, "Analysis", "h1_model_definitions_bayes.R"))
  
  mods.h1.next_year.raw.bayes <- df.country.aid.demean.next_year.both %>%
  nest(-m) %>%
  mutate(mod.h1.barriers.total = data %>% map(mod.h1.barriers.total.bayes,
                                              "total.oda_log_next_year"),
         mod.h1.barriers.new = data %>% map(mod.h1.barriers.new.bayes,
                                            "total.oda_log_next_year"),
         mod.h1.type.total = data %>% map(mod.h1.type.total.bayes,
                                          "total.oda_log_next_year"),
         mod.h1.type.new = data %>% map(mod.h1.type.new.bayes,
                                        "total.oda_log_next_year"),
         mod.h1.csre = data %>% map(mod.h1.csre.bayes,
                                    "total.oda_log_next_year"))
}
```

```{r h1-models-bayes-2, warning=FALSE, message=FALSE}
if (run.rstan) {
  mods.h1.after_2.raw.bayes <- df.country.aid.demean.after_2.both %>%
  nest(-m) %>%
  mutate(mod.h1.barriers.total = data %>% map(mod.h1.barriers.total.bayes,
                                              "total.oda_log_next_year"),
         mod.h1.barriers.new = data %>% map(mod.h1.barriers.new.bayes,
                                            "total.oda_log_next_year"),
         mod.h1.type.total = data %>% map(mod.h1.type.total.bayes,
                                          "total.oda_log_next_year"),
         mod.h1.type.new = data %>% map(mod.h1.type.new.bayes,
                                        "total.oda_log_next_year"),
         mod.h1.csre = data %>% map(mod.h1.csre.bayes,
                                    "total.oda_log_next_year"))
}
```

```{r h1-models-bayes-5, warning=FALSE, message=FALSE}
if (run.rstan) {
  mods.h1.after_5.raw.bayes <- df.country.aid.demean.after_5.both %>%
  nest(-m) %>%
  mutate(mod.h1.barriers.total = data %>% map(mod.h1.barriers.total.bayes,
                                              "total.oda_log_next_year"),
         mod.h1.barriers.new = data %>% map(mod.h1.barriers.new.bayes,
                                            "total.oda_log_next_year"),
         mod.h1.type.total = data %>% map(mod.h1.type.total.bayes,
                                          "total.oda_log_next_year"),
         mod.h1.type.new = data %>% map(mod.h1.type.new.bayes,
                                        "total.oda_log_next_year"),
         mod.h1.csre = data %>% map(mod.h1.csre.bayes,
                                    "total.oda_log_next_year"))
}
```

### Results

#### Non-imputed frequentist models

```{r h1-table, results="asis"}
stargazer(filter(mods.h1.next_year, m == "original")$model,
          type="html",
          add.lines=list(c("Country random effects", rep("Yes", 5)),
                         c("Year random effects", rep("Yes", 5))))
```

#### Imputed and melded frequentist models

Effect on ODA after 1 year:

```{r h1-melded-table-1, results="asis", warning=FALSE}
h1.terms <- c("barriers.total_between", "barriers.total_within", "barriers.total_new", "advocacy_between", "advocacy_within", "entry_between", "entry_within", "funding_between", "funding_within", "advocacy_new", "entry_new", "funding_new", "csre_between", "csre_within", "polity_between", "polity_within", "gdp.capita_log_between", "gdp.capita_log_within", "trade.pct.gdp_between", "trade.pct.gdp_within", "corruption_between", "corruption_within", "internal.conflict.past.5TRUE", "natural_disaster.occurrence", "(Intercept)")

h1.model.order <- c("mod.h1.barriers.total", "mod.h1.barriers.new", "mod.h1.type.total", "mod.h1.type.new", "mod.h1.csre")

stargazer.fake(mods.h1.next_year.melded, h1.terms, h1.model.order)
```

Effect on ODA after 2 years:

```{r h1-melded-table-2, results="asis", warning=FALSE}
stargazer.fake(mods.h1.after_2.melded, h1.terms, h1.model.order)
```

Effect on ODA after 5 years:

```{r h1-melded-table-5, results="asis", warning=FALSE}
stargazer.fake(mods.h1.after_5.melded, h1.terms, h1.model.order)
```

### Predicted ODA

`barriers.total_between` is significant at the 95% level in the first model, and it's substantially so. The grey band below indicates the 90% prediction interval, calculated with 1000 simulated draws from model results (these intervals are waaaay too big for now; they'll be more accurate when running the Bayesian models). One additional anti-NGO law is associated with a 36% increase in ODA in the following year *between* countries in the panel.

```{r h1-visualize, warning=FALSE}
model.to.use <- mods.h1.next_year %>%
  filter(m == "original", model.name == "mod.h1.barriers.total")

model.to.use <- model.to.use$model[[1]]

new.data <- model.to.use@frame %>%
  select(-barriers.total_between) %>%
  summarise_all(typical) %>%
  mutate(id = 1) %>%
  right_join(expand.grid(barriers.total_between = seq(0, 12, 0.1),
                         id = 1), by="id")

plot.predict <- merTools::predictInterval(merMod=model.to.use, newdata=new.data, 
                                          level=0.90, n.sims=1000,
                                          stat="median", type="linear.prediction",
                                          include.resid.var=TRUE) %>%
  rename(pred = fit, pred.upper = upr, pred.lower = lwr) %>%
  bind_cols(augment(model.to.use, newdata=new.data))

ggplot(plot.predict, aes(x=barriers.total_between, y=.fitted)) + 
  geom_line() + 
  geom_ribbon(aes(ymin=pred.lower, ymax=pred.upper),
              alpha=0.3, colour=NA) + 
  labs(x="Total barriers (between; average value for each country)", y="Predicted log ODA") +
  theme_donors()
```

Looking at the overall effect of the civil society regulatory environment, though, does yield a significant effect. A one point increase in the CSRE is associated with a 41% increase in ODA in the following year (and vice versa; worsening CSRE leads to a reduction in aid) *within* countries in the panel.

```{r h1-visualize1, warning=FALSE}
model.to.use <- mods.h1.next_year %>%
  filter(m == "original", model.name == "mod.h1.csre")

model.to.use <- model.to.use$model[[1]]

new.data <- model.to.use@frame %>%
  select(-csre_within) %>%
  summarise_all(typical) %>%
  mutate(id = 1) %>%
  right_join(expand.grid(csre_within = seq(-4, 4, 0.1),
                         id = 1), by="id")

plot.predict <- merTools::predictInterval(merMod=model.to.use, newdata=new.data, 
                                          level=0.90, n.sims=1000,
                                          stat="median", type="linear.prediction",
                                          include.resid.var=TRUE) %>%
  rename(pred = fit, pred.upper = upr, pred.lower = lwr) %>%
  bind_cols(augment(model.to.use, newdata=new.data))

ggplot(plot.predict, aes(x=csre_within, y=.fitted)) + 
  geom_line() + 
  geom_ribbon(aes(ymin=pred.lower, ymax=pred.upper),
              alpha=0.3, colour=NA) + 
  labs(x="CSRE (within; difference from mean)", y="Predicted log ODA") +
  theme_donors()
```
