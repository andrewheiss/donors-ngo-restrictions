---
title: "Models"
author: "Suparna Chaudhry and Andrew Heiss"
date: "`r format(Sys.time(), '%F')`"
output: 
  html_document: 
    code_folding: hide
    css: ../html/fixes.css
    fig_height: 3.5
    fig_width: 5
    highlight: pygments
    includes:
      after_body: ../html/add_home_link.html
    theme: spacelab
    toc: yes
    toc_depth: 4
    toc_float: yes
---

```{r load-libraries, message=FALSE}
knitr::opts_chunk$set(cache=FALSE, fig.retina=2,
                      tidy.opts=list(width.cutoff=120),  # For code
                      options(width=120))  # For output

library(tidyverse)
library(stringr)
library(forcats)
library(stargazer)
library(lme4)
library(modelr)
library(broom)

source(file.path(PROJHOME, "lib", "graphics.R"))
source(file.path(PROJHOME, "lib", "pandoc.R"))
source(file.path(PROJHOME, "lib", "bayes.R"))

source(file.path(PROJHOME, "Analysis", "robustness_models_definitions.R"))
source(file.path(PROJHOME, "Analysis", "h1_model_definitions.R"))
source(file.path(PROJHOME, "Analysis", "h2_model_definitions.R"))
source(file.path(PROJHOME, "Analysis", "h3_model_definitions.R"))
source(file.path(PROJHOME, "Analysis", "h4_model_definitions.R"))

my.seed <- 1234
set.seed(my.seed)

run.rstan <- FALSE
```

```{r load-data, cache=TRUE, message=FALSE}
df.country.aid <- readRDS(file.path(PROJHOME, "Data", "data_clean",
                                "df_country_aid_no_imputation.rds"))

df.country.aid.impute <- readRDS(file.path(PROJHOME, "Data", "data_clean",
                                           "df_country_aid_imputation.rds"))

df.country.aid.impute.m10 <- readRDS(file.path(PROJHOME, "Data", "data_clean",
                                               "df_country_aid_imputation_m10.rds"))

dcjw.questions.clean <- read_csv(file.path(PROJHOME, "Data", "data_clean",
                                           "dcjw_questions.csv"))
dcjw.responses.clean <- read_csv(file.path(PROJHOME, "Data", "data_clean",
                                           "dcjw_responses.csv"))

# Load clean coefficient names and append "within" and "between" to them,
# resulting in a giant table of possible coefficient names
coef.names <- read_csv(file.path(PROJHOME, "Data", "data_clean",
                                 "coef_names.csv"))

coef.names.within <- coef.names %>%
  mutate(term = paste0(term, "_within"),
         term_plot = paste0(term_clean, "\n(within)"),
         term_clean = paste0(term_clean, "~within~"))

coef.names.between <- coef.names %>%
  mutate(term = paste0(term, "_between"),
         term_plot = paste0(term_clean, "\n(between)"),
         term_clean = paste0(term_clean, "~between~"))

coef.names.all <- bind_rows(coef.names, coef.names.within, coef.names.between) %>%
  mutate(term_plot = ifelse(is.na(term_plot), term_clean, term_plot))


# Combine original data and imputed data so calculations can happen at the same time
df.country.aid.both <- bind_rows(df.country.aid, df.country.aid.impute)

# Combine m=10 imputed data too since we use it in some robustness checks.
# Imputations 6-10 are later removed
df.country.aid.all <- bind_rows(df.country.aid, df.country.aid.impute.m10)

# All the missing values have been taken care of, but final years for leaded
# variables *are* still missing (i.e. there's no aid data for 2014, so
# total.oda_log_next_year will be NA in 2013). For this fancy random effects
# regression to work, the demeaned variables have to be based on the means of
# all rows included in the regression, so they can't include rows that are
# dropped because of missingness. This means we have to make separate demeaned
# datasets for *_after_2 and *_after_5, but ¯\_(ツ)_/¯
df.country.aid.demean.next_year.all <- df.country.aid.all %>%
  filter(!is.na(total.oda_log_next_year)) %>%
  group_by(m, cowcode) %>%
  mutate_at(vars(barriers.total, advocacy, entry, funding, 
                 polity, gdp.capita_log, gdp.capita, trade.pct.gdp, corruption, csre,
                 total.oda_log),
            funs(between = mean(., na.rm=TRUE),  # meaned
                 within = . - mean(., na.rm=TRUE))) %>%  # demeaned
  ungroup()

df.country.aid.us.demean.next_year.all <- df.country.aid.all %>%
  filter(!is.na(prop.ngo.dom_logit_next_year)) %>%
  filter(year > 1999) %>%
  group_by(m, cowcode) %>%
  mutate_at(vars(barriers.total, advocacy, entry, funding, 
                 polity, gdp.capita_log, gdp.capita, trade.pct.gdp, corruption, csre,
                 total.oda_log),
            funs(between = mean(., na.rm=TRUE),  # meaned
                 within = . - mean(., na.rm=TRUE))) %>%  # demeaned
  ungroup()

# Divide demeaned data into separate data frames: original, imputed (m=5), and imputed (m=10)
df.country.aid.demean.next_year.both <- 
  filter(df.country.aid.demean.next_year.all, !(m %in% paste0("imp", 6:10)))

df.country.aid.demean.next_year <- 
  filter(df.country.aid.demean.next_year.all, m == "original")

df.country.aid.us.demean.next_year.both <- 
  filter(df.country.aid.us.demean.next_year.all, !(m %in% paste0("imp", 6:10)))

df.country.aid.us.demean.next_year <- 
  filter(df.country.aid.us.demean.next_year.all, m == "original")

df.country.aid.demean.next_year.impute <- 
  filter(df.country.aid.demean.next_year.all, 
         m != "original", !(m %in% paste0("imp", 6:10)))

df.country.aid.demean.next_year.impute.m10 <- 
  filter(df.country.aid.demean.next_year.all, m != "original")

# Demean data with total.oda_log leaded by 2 years and 5 years
# After 2 years
df.country.aid.demean.after_2.both <- df.country.aid.both %>%
  filter(!is.na(total.oda_log_after_2)) %>%
  group_by(m, cowcode) %>%
  mutate_at(vars(barriers.total, advocacy, entry, funding, 
                 polity, gdp.capita_log, gdp.capita, trade.pct.gdp, corruption, csre,
                 total.oda_log),
            funs(between = mean(., na.rm=TRUE),  # meaned
                 within = . - mean(., na.rm=TRUE))) %>%  # demeaned
  ungroup()

df.country.aid.demean.after_2 <- 
  filter(df.country.aid.demean.after_2.both, m == "original")

df.country.aid.demean.after_2.impute <- 
  filter(df.country.aid.demean.after_2.both, m != "original")

# After 5 years
df.country.aid.demean.after_5.both <- df.country.aid.both %>%
  filter(!is.na(total.oda_log_after_5)) %>%
  group_by(m, cowcode) %>%
  mutate_at(vars(barriers.total, advocacy, entry, funding, 
                 polity, gdp.capita_log, gdp.capita, trade.pct.gdp, corruption, csre,
                 total.oda_log),
            funs(between = mean(., na.rm=TRUE),  # meaned
                 within = . - mean(., na.rm=TRUE))) %>%  # demeaned
  ungroup()

df.country.aid.demean.after_5 <- 
  filter(df.country.aid.demean.after_5.both, m == "original")

df.country.aid.demean.after_5.impute <- 
  filter(df.country.aid.demean.after_5.both, m != "original")
```

```{r helpful-functions}
stars <- function(p) {
  out <- symnum(p, cutpoints=c(0, 0.01, 0.05, 0.1, 1),
                symbols=c("***", "**", "*", ""))
  as.character(out)
}

fixed.digits <- function(x, n=2) {
  formatC(x, digits=n, format="f")
}

# Inverse logit, with the ability to account for adjustments
# via http://stackoverflow.com/a/23845527/120898
inv.logit <- function(f, a) {
  a <- (1 - 2 * a)
  (a * (1 + exp(f)) + (exp(f) - 1)) / (2 * a * (1 + exp(f)))
}

# Take apart the pieces of a random effects formula and rebuild it
build.formula <- function(DV, IVs) {
  terms.all <- attr(terms(IVs), "term.labels")
  terms.fixed <- terms.all[!stringr::str_detect(terms.all, "\\|")]
  terms.rand <- sapply(findbars(formula(IVs)),function(x) paste0("(", deparse(x), ")"))
  
  reformulate(c(terms.fixed, terms.rand), response=DV)
}

# Meld a bunch of imputed models
meld.imputed.models <- function(model.data, exponentiate=FALSE) {
  models.df <- model.data$glance[[1]]$df.residual
  
  models.tidy <- model.data %>%
    select(tidy) %>%
    unnest(.id="imputation")
  
  just.estimates <- models.tidy %>% 
    filter(group == "fixed") %>%
    select(imputation, term, estimate) %>%
    spread(term, estimate) %>%
    select(-imputation)
  
  just.ses <- models.tidy %>%
    filter(group == "fixed") %>%
    select(imputation, term, std.error) %>%
    spread(term, std.error) %>%
    select(-imputation)

  # If no imputed data was passed in, use the actual estimates and SEs
  if (nrow(just.estimates) > 1) {
    melded <- Amelia::mi.meld(just.estimates, just.ses)
  } else {
    melded <- list(q.mi = just.estimates, se.mi = just.ses)
  }

  melded.tidy <- as.data.frame(cbind(t(melded$q.mi), 
                                     t(melded$se.mi))) %>%
    magrittr::set_colnames(c("estimate", "std.error")) %>%
    mutate(term = rownames(.)) %>%
    select(term, everything()) %>%
    mutate(statistic = estimate / std.error,
           conf.low = estimate + std.error * qt(0.025, models.df),
           conf.high = estimate + std.error * qt(0.975, models.df),
           p.value = 2 * pt(abs(statistic), models.df, lower.tail=FALSE),
           stars = stars(p.value))
  
  if (exponentiate) {
    # Convert SEs to odds ratios. This isn't entirely 100% accurate, since the
    # melded coefficient variances (i.e. diag(vcov(.))) are just averaged, not
    # melded with Amelia's fancy mi.meld(), but ¯\_(ツ)_/¯
    #
    # https://www.andrewheiss.com/blog/2016/04/25/convert-logistic-regression-standard-errors-to-odds-ratios-with-r/
    fixed.coefs.var <- model.data %>%
      mutate(var.diag = model %>% map(~ diag(vcov(.)))) %>%
      select(var.diag, model) %>% unnest(var.diag)
    
    just.var <- models.tidy %>%
      filter(group == "fixed") %>%
      select(imputation, term) %>%
      bind_cols(fixed.coefs.var) %>%
      group_by(term) %>%
      summarise(var.diag = mean(var.diag))
    
    melded.tidy <- melded.tidy %>%
      left_join(just.var, by="term") %>%
      mutate(or = exp(estimate),
             or.se = sqrt(or^2 * var.diag),
             or.upper = or + (qnorm(0.975) * or.se),
             or.lower = or + (qnorm(0.025) * or.se))
  }
  
  melded.tidy
}

# Expects a data frame with a column named tidy.melded and a row for model
# names. Term names are based on the first model in the data column for each
# row, and are filtered through stargazer to get the correct row order.
stargazer.fake <- function(df, caption=NULL, note=NULL, exponentiate=FALSE) {
  # Create a blank row with a bolded row name
  header.row <- function(header) {
    data_frame(term = paste0("**", header, "**"), 
               models = df$model.name, value = "") %>%
    spread(models, value)
  }
  
  note.row <- function(note) {
    crossing(term = note,
             models = df$model.name, value = "") %>%
      spread(models, value) %>%
      # Sort based on original note order
      slice(match(note, term))
  }

  coef.order.models <- df %>%
    # Select just the first row of each model
    unnest(data) %>%
    # Sometimes there are duplicate column names
    # magrittr::set_colnames(make.unique(colnames(.))) %>%
    # Keep order of model.name
    mutate(model.name = ordered(fct_inorder(model.name))) %>%
    group_by(model.name) %>%
    slice(1) %>% ungroup() %>%
    select(model) %>% as.list()
  
  # Use stargazer to get the coefficient order. I tried recreating stargazer's
  # coefficient ordering algorithm but it's way too complicated. So instead, we
  # cheat and let stargazer do the heavy lifting, save the output to a string,
  # and then extract the coefficient names with str_extract. Super super hacky,
  # but it works.
  #
  # See http://stackoverflow.com/a/41801861/120898
  capture.output({
    stargazer.coefs <- stargazer::stargazer(coef.order.models, 
                                            type="text", table.layout="t")
  }, file="/dev/null")
  
  coef.order <- setdiff(stringr::str_extract(stargazer.coefs, "^[\\w\\.]*"), c(""))
  
  # Fixed parts
  fixed.tidy <- df %>%
    unnest(tidy.melded)
  
  if (exponentiate) {
    fixed.coefs <- fixed.tidy %>%
      mutate(fancy = paste0(fixed.digits(or, 3),
                          stars, "\\ \n(",
                          fixed.digits(or.se, 3),
                          ")"))
  } else {
    fixed.coefs <- fixed.tidy %>%
      mutate(fancy = paste0(fixed.digits(estimate, 3),
                          stars, "\\ \n(",
                          fixed.digits(std.error, 3),
                          ")"))
  }
  
  fixed.coefs <- fixed.coefs %>%
    select(model.name, term, fancy) %>%
    spread(model.name, fancy, fill="") %>%
    # Clean up term names
    mutate(term = stringr::str_replace(term, "TRUE$|FALSE$", ""),
           term = recode(term, `(Intercept)` = "Constant")) %>%
    # Use stargazer's coefficient order
    mutate(term = factor(term, levels=coef.order, ordered=TRUE)) %>%
    arrange(term) %>%
    mutate(term = as.character(term)) %>%
    left_join(coef.names.all, by="term") %>%
    mutate(term_clean = ifelse(term == "Constant", "Constant", term_clean)) %>%
    select(-term) %>% rename(term = term_clean) %>%
    select_(.dots = c("term", df$model.name))
  
  # Random parts
  random.coef.order.raw <- df %>%
    unnest(data) %>%
    # unnest(data) %>% magrittr::set_colnames(make.unique(colnames(.))) %>%
    select(model.name, model) %>%
    mutate(ranef = model %>% map(~ as.data.frame(VarCorr(.)))) %>%
    unnest(ranef)
  random.coef.order <- c(setdiff(unique(random.coef.order.raw$grp), "Residual"), "Residual")
  
  random.coefs <- df %>%
    unnest(data) %>%
    unnest(tidy) %>%
    filter(group != "fixed") %>%
    rename(term.raw = term, term = group) %>%
    group_by(model.name, term) %>%
    summarise(avg.random.sd = mean(estimate),
              sd.random.sd = sd(estimate)) %>%
    mutate(fancy = paste0(fixed.digits(avg.random.sd, 3),
                          "\\ \n(",
                          ifelse(is.na(sd.random.sd), "NA", fixed.digits(sd.random.sd, 3)),
                          ")")) %>%
    select(model.name, term, fancy) %>%
    spread(model.name, fancy, fill="") %>%
    mutate(term = factor(term, levels=random.coef.order, ordered=TRUE)) %>%
    arrange(term) %>% mutate(term = as.character(term)) %>%
    left_join(coef.names.all, by="term") %>%
    mutate(term_clean = ifelse(term == "Residual", 
                               "Residual random error ($\\sigma$)", term_clean)) %>%
    select(-term) %>% select(term=term_clean, everything())

  # Create the bottom half of the table
  # Calculate the average log likelihood for all imputed models
  avg.loglik <- df %>%
    unnest(data) %>% unnest(glance) %>%
    group_by(model.name) %>%
    summarise(avg.loglik = as.character(round(mean(logLik), 2))) %>%
    mutate(term = "Log likelihood (mean)") %>%
    spread(model.name, avg.loglik)

  # Imputation frames
  n.obs <- df %>%
    unnest(data) %>%
    mutate(n = model %>% map_int(~ nrow(.@frame))) %>%
    select(model.name, n) %>%
    group_by(model.name) %>% slice(1) %>% ungroup() %>%
    mutate(term = "Observations",
           n = scales::comma(n)) %>%
    spread(model.name, n)
  
  n.m <- df %>%
    mutate(m.new = data %>% map_int(~ nrow(.))) %>%
    select(model.name, m.new) %>% 
    mutate(m.new = ifelse(m.new == 1, 0, m.new),
           m.new = as.character(m.new)) %>%
    mutate(term = "Imputed datasets (*m*)") %>%
    spread(model.name, m.new)

  bottom.details <- bind_rows(n.obs, avg.loglik, n.m)
  
  if (exponentiate) {
    fixed.title <- "Fixed part (odds ratios)"
    random.title <- "Random part (original coefficients)"
  } else {
    fixed.title <- "Fixed part"
    random.title <- "Random part"
  }

  if (!is.null(note)) {
    notes <- bind_rows(header.row("Notes"), note.row(note))
  } else {
    notes <- NULL
  }
  
  nice.top.bottom <- bind_rows(header.row(fixed.title), fixed.coefs, 
                               header.row(random.title), random.coefs,
                               header.row("Model details"), bottom.details,
                               notes) %>%
    select_(.dots = c("term", df$model.name))
  
  # Make column names (1), (2), etc.
  # TODO: Allow for custom column names
  colnames(nice.top.bottom) <- c(" ", paste0("(", 1:length(df$model.name), ")"))
  
  # All columns are centered except the first
  # TODO: MAYBE: Let this be user configurable
  table.align <- paste0(c("l", rep("c", length(df$model.name))), collapse="")
  
  pandoc.table.return(nice.top.bottom, keep.line.breaks=TRUE,
                      justify=table.align, caption=caption)
}
```

## Dependent variables

As explained in each section below, we have to transform and operationalize the dependent variable (foreign aid) in different ways for each hypothesis. The table belows summarizes each simplified model specification.

```{r dv-data, results="asis"}
all.models <- tribble(
  ~h, ~Hypothesis, ~math,
  1, "H~1~", "ln( \\text{ODA}_{\\text{OECD}} )_{i, t+1} = \\text{NGO legislation}_{it} + \\text{controls}_{it}",
  2, "H~2~", "ln( \\frac{\\text{contentious ODA}_{\\text{OECD}}}{\\text{noncontentious ODA}_{\\text{OECD}}} )_{i, t+1} = \\text{NGO legislation}_{it} + \\text{controls}_{it}",
  3, "H~3~", "ln( \\frac{\\text{Aid to (domestic or foreign) NGOs}_{\\text{USAID}}}{\\text{Aid to other channels}_{\\text{USAID}}} )_{i, t+1} = \\text{NGO legislation}_{it} + \\text{controls}_{it}",
  4, "H~4~", "ln( \\text{ODA in neighboring countries}_{\\text{OECD}} )_{i, t+1} = \\text{NGO legislation}_{it} + \\text{controls}_{it}"
) %>%
  mutate(`Simplified model` = paste0("$", math, "$"))

caption <- "Transformations and operationalizations of aid in each hypothesis {#tbl:all-models-dvs}"
all.models.table <- pandoc.table.return(select(all.models, Hypothesis, 
                                               `Simplified model`), 
                                        justify="ll", caption=caption)
cat(all.models.table)
cat(all.models.table, file=file.path(PROJHOME, "Output", "tbl-all-models-dvs.md"))
```


## General model specifications and controls

We use a standard set of controls in each model ([explained in more detail here](../Data/get_merge_data.html#other_controls_and_alternative_hypotheses)):

- Democracy: `polity`
- Wealth: `gdp.capita_log` (logged so it's on the same scale as the other variables) 
- Government capacity: `corruption`
- Bad stuff: `internal.conflict.past.5` and `natural_disaster.occurrence`

Following [Bell and Jones (2015)](http://dx.doi.org/10.1017/psrm.2014.7), we use crossed random effects for country and year and use a combination of meaned and demeaned versions of each continuous variable to estimate both the within and between effects of each variable. 

$$ y_{i, t + 1} = \beta_0 + \beta_1 (x_{it} - \bar{x}_i) + \beta_2 \bar{x}_i + \ldots $$

This approach has multiple benefits. The coefficients for the demeaned variables are roughly equivalent to their corresponding coefficients in a fixed effects model, but a fixed effects model assumes that the between effect (captured by the mean variables) is 0, which is not the case. A random effects model specified in this manner is more interpretable, as it clearly separates the within and between effects (again, within = demeaned, between = mean).

Here's proof of how it works in some simple models. Model 1 is a basic OLS with country fixed effects. Model 2 is a basic OLS with country random effects, but potentially misspecified, since the between and within effects are conflated. Model 3 is a basic OLS with country random effects specified with between (mean; $\bar{x}_i$) and within (demeaned; $x_{it} - \bar{x}_i$) coefficients. The demeaned/within coefficients in Model 3 are identical to the fixed effects coefficients in Model 1. If rows had been dropped because of listwise deletion (like, if there were missing values in one of independent variables), the coefficients would be slightly off, since the demeaned values would have been based on group means that included the values that were dropped (e.g. all 2013 rows are dropped because of lags, but the group means included 2013). This isn't  a problem in these reduced models, but that's one reason we impute all the data—we need the data to be as complete as possible to get the most accurate random effects.

```{r fixed-random-example, results="asis"}
mod.test.fe <- lm(total.oda_log_next_year ~ 
                    barriers.total + polity + gdp.capita_log + 
                    as.factor(cowcode),
                  data=df.country.aid.demean.next_year)

mod.test.re <- lmer(total.oda_log_next_year ~ 
                    barriers.total + polity + gdp.capita_log + 
                    (1 | cowcode),
                  data=df.country.aid.demean.next_year)

mod.test.re.fancy <- lmer(total.oda_log_next_year ~ 
                            barriers.total_between + barriers.total_within +
                            polity_between + polity_within + 
                            gdp.capita_log_between + gdp.capita_log_within +
                            (1 | cowcode),
                          data=df.country.aid.demean.next_year)

stargazer(mod.test.fe, mod.test.re, mod.test.re.fancy,
          type="html", omit="factor", 
          add.lines=list(c("Country effects",
                           c("Fixed", "Random", "Random"))),
          keep.stat=c("n"))
```

\
All of the models we run use imputed data ($m = 5$) with crossed year and country random effects. Most explanatory and control variables are included in their meaned and demeaned forms, except for any indicator variables (since you can't really average binary data). Additionally, we include the regular form of the current year's ODA to account for temporal autocorrelation in aid. We do not split current ODA into within and between versions so that mathematically it can be subtracted out of the next year's ODA in the dependent variable. Other mixed models functions like `nlme::lme()` allow you to define autoregressive correlation structures, but `lme4::lmer()` doesn't, so we account for time with this differenced approach instead. It's not perfect, but it works:

```{r show.acf.lags}
mod.test.no.oda <- lmer(total.oda_log_next_year ~ 
                          barriers.total_between + barriers.total_within +
                          polity_between + polity_within + 
                          gdp.capita_log_between + gdp.capita_log_within +
                          (1 | cowcode) + (1 | year),
                        data=filter(df.country.aid.demean.next_year.impute,
                                    m == "imp1"))

mod.test.oda.split <- lmer(total.oda_log_next_year ~ 
                             barriers.total_between + barriers.total_within +
                             polity_between + polity_within + 
                             total.oda_log_between + total.oda_log_within +
                             gdp.capita_log_between + gdp.capita_log_within +
                             (1 | cowcode) + (1 | year),
                           data=filter(df.country.aid.demean.next_year.impute,
                                       m == "imp1"))

mod.test.oda.nosplit <- lmer(total.oda_log_next_year ~ 
                               barriers.total_between + barriers.total_within +
                               polity_between + polity_within + 
                               total.oda_log +
                               gdp.capita_log_between + gdp.capita_log_within +
                               (1 | cowcode) + (1 | year),
                             data=filter(df.country.aid.demean.next_year.impute,
                                         m == "imp1"))

resid.no.oda <- acf(residuals(mod.test.no.oda), plot=FALSE)
resid.oda <- acf(residuals(mod.test.oda.nosplit), plot=FALSE)

ci.line <- qnorm((1 + 0.95) / 2) / sqrt(resid.no.oda$n.used)

acf.plot.data <- bind_rows(
  data_frame(Lag = resid.no.oda$lag[,,1], ACF = resid.no.oda$acf[,,1], 
             model = "No ODA"),
  data_frame(Lag = resid.oda$lag[,,1], ACF = resid.oda$acf[,,1], 
             model = "Current year’s ODA")
)

ggplot(acf.plot.data, aes(x=Lag, y=ACF, fill=model)) +
  geom_bar(stat="identity", position=position_dodge(width=1), width=0.5) +
  geom_hline(yintercept=0, size=1) +
  geom_hline(yintercept=c(ci.line, -ci.line), size=0.5, linetype="dashed") +
  guides(fill=guide_legend(title=NULL)) +
  theme_donors()
```

Not splitting current ODA into within and between also fixes another sticky mathematical issue. When the models are run with within and current ODA, the $\sigma$ value for within-country variability becomes 0 for whatever reason (maybe it swallows up too much country level variability?). When $\sigma = 0$, the between-group variability is too small to fully account for between effects, resulting in a "degenerate model" (see [pages 10–11 here](http://lme4.r-forge.r-project.org/lMMwR/lrgprt.pdf)) and influencing the coefficients in weird ways. See below, where Model 1 uses the split current ODA and Model 2 doesn't: $\sigma$ in Model 2 exists and the coefficients are better estimated.

```{r h1-table-results, results="asis"}
stargazer(mod.test.oda.split, mod.test.oda.nosplit,
          type="html", keep.stat=c("n"))

bind_rows(
  as.data.frame(VarCorr(mod.test.oda.split)) %>% mutate(model="(1)"),
  as.data.frame(VarCorr(mod.test.oda.nosplit)) %>% mutate(model="(2)")
) %>% 
  mutate(grp = ordered(fct_inorder(grp))) %>%
  select(`Random variable` = grp, sdcor, model) %>%
  spread(model, sdcor) %>% pandoc.table()
```

---

## H~1~: Donors reduce aid in response to legislation

> **H~1~**: In response to restrictive NGO legislation, bilateral, multilateral, and private donors may reduce their aid to repressive countries.

$$`r filter(all.models, h==1)$math`$$

Our dependent variable for this hypothesis is the log of ODA (constant 2011 dollars), leaded by one year so we don't have to lag every other independent variable. As a robustness check, we also include models with log ODA leaded by 2 years and 5 years to account the implementation period following the passage of a law.

We look at NGO legislation in a few different ways:

- `barriers.total`: Number of anti-NGO legal barriers in a country-year
- `barriers.total_new`: Indicator marking if a new anti-NGO barrier was passed in a country year
- `advocacy + entry + funding`: Number of anti-NGO legal barriers by type of barrier
- `advocacy_new + entry_new + funding_new`: Indicators marking new type of barrier
- `csre`: Civil society regulatory environment index (CSRE), ranging from roughly -4 to 4 (higher values = better civil society regulations)

```{r h1-models-1, warning=FALSE, message=FALSE, cache=TRUE}
# Run models on each of the datasets (original and imputed) and save in a big data frame
mods.h1.next_year.raw <- df.country.aid.demean.next_year.both %>%
  nest(-m) %>%
  mutate(mod.h1.barriers.total = data %>% map(mod.h1.barriers.total,
                                              "total.oda_log_next_year"),
         mod.h1.barriers.new = data %>% map(mod.h1.barriers.new,
                                            "total.oda_log_next_year"),
         mod.h1.type.total = data %>% map(mod.h1.type.total,
                                          "total.oda_log_next_year"),
         mod.h1.type.new = data %>% map(mod.h1.type.new,
                                        "total.oda_log_next_year"),
         mod.h1.csre = data %>% map(mod.h1.csre,
                                    "total.oda_log_next_year"))

# Get model details and parameters
mods.h1.next_year <- mods.h1.next_year.raw %>%
  gather(model.name, model, -m, -data) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy, conf.int=TRUE))

# Meld the imputed models
mods.h1.next_year.melded <- mods.h1.next_year %>%
  filter(m != "original") %>%
  group_by(model.name) %>%
  nest() %>%
  mutate(tidy.melded = data %>% map(meld.imputed.models))
```

```{r h1-models-bayes-1, warning=FALSE, message=FALSE}
if (run.rstan) {
  source(file.path(PROJHOME, "Analysis", "h1_model_definitions_bayes.R"))
  
  mods.h1.next_year.raw.bayes <- df.country.aid.demean.next_year %>%
  nest(-m) %>%
  mutate(mod.h1.barriers.total = data %>% map(mod.h1.barriers.total.bayes,
                                              "total.oda_log_next_year"),
         mod.h1.barriers.new = data %>% map(mod.h1.barriers.new.bayes,
                                            "total.oda_log_next_year"),
         mod.h1.type.total = data %>% map(mod.h1.type.total.bayes,
                                          "total.oda_log_next_year"),
         mod.h1.type.new = data %>% map(mod.h1.type.new.bayes,
                                        "total.oda_log_next_year"),
         mod.h1.csre = data %>% map(mod.h1.csre.bayes,
                                    "total.oda_log_next_year"))
}
```

### Results

```{r plot-h1-coefs, fig.width=7, fig.height=4}
vars.to.plot <- c("barriers.total_within", "barriers.total_between",
                  "barriers.total_new",
                  "advocacy_within", "advocacy_between", 
                  "entry_within", "entry_between", 
                  "funding_within", "funding_between",
                  "advocacy_new", "entry_new", "funding_new",
                  "csre_within", "csre_between")

coefs.raw.h1 <- mods.h1.next_year.melded %>%
  unnest(tidy.melded) %>%
  filter(term != "(Intercept)",
         term %in% vars.to.plot) %>%
  left_join(coef.names.all, by="term") %>%
  mutate(term = factor(term, levels=vars.to.plot, ordered=TRUE)) %>%
  arrange(desc(term)) %>%
  mutate(term_plot = ordered(fct_inorder(term_plot))) %>%
  mutate(coef.type = case_when(
    str_detect(.$term, "_within") ~ "Within",
    str_detect(.$term, "_between") ~ "Between",
    TRUE ~ "Not split"
  )) %>% 
  mutate(coef.type = factor(coef.type, levels=c("Within", "Between", "Not split"),
                            ordered=TRUE)) %>%
  mutate(model.name = factor(model.name, levels=rev(unique(model.name)), ordered=TRUE))

ggplot(coefs.raw.h1, aes(y=term_plot, x=estimate, colour=model.name)) + 
  geom_vline(xintercept=0, colour="grey50", size=0.5) + 
  geom_pointrangeh(aes(xmin=conf.low, xmax=conf.high), size=.5) + 
  labs(x="Estimate", y=NULL) +
  scale_colour_manual(values=model.colors) +
  guides(color=FALSE) +
  theme_donors() + 
  facet_wrap(~ coef.type, scales="free")
```

```{r h1-melded-table-1, results="asis", warning=FALSE}
caption <- "The effect of anti-NGO legislation on OECD overseas development assistance (ODA) in the following year (H~1~), full models {#tbl:h1-coefs}"
note <- c("\\* *p* < 0.10; \\*\\* *p* < 0.05; \\*\\*\\* *p* < 0.01",
          "Dependent variable log transformed.",
          "Coefficients and standard errors\\ \naveraged across all imputations.")
table.h1 <- stargazer.fake(mods.h1.next_year.melded, caption=caption, note=note)

cat(table.h1)
cat(table.h1, file=file.path(PROJHOME, "Output",
                             "tbl-h1-coefs.md"))
```

### Model diagnostics

Country intercepts vary with an SD of 0.295 (etc.), year intercepts vary with an SD of 0.272 (etc.), and the SD of error not accounted for by either within-country or within-year variability is 3 (etc.)


### Predicted ODA

The total number of anti-NGO legal barriers has a significant negative effect on ODA in the following year—adding a new barrier beyond a country's average number of all time barriers is associated with a 7.4% reduction in aid in the next year (p < 0.1). This difference has substantive significant, as seen in the simulated plot below, which shows 50 model simulations from each of the 5 imputed datasets across a range of differences from the average number of NGO laws in an average country (with all independent variables held at their mean or modal values). (And amazingly, because of math, the slope of the thick line below is essentially the coefficient from the model, 0.7ish.)

```{r h1-simulate-total, warning=FALSE, fig.width=6}
# Make predictions inside each dataset, then average them. So says Gary King:
# https://lists.gking.harvard.edu/pipermail/gov2001/2003-May/005327.html
simulate.predictions.barriers <- function(x) {
  new.data <- x@frame %>%
    select(-c(barriers.total_within, year, cowcode)) %>%
    summarise_all(typical) %>%
    mutate(id = 1,
           total.oda_log_next_year = NA) %>%
    right_join(expand.grid(barriers.total_within = seq(-5, 5, 0.5),
                           cowcode = 1000:1050,
                           year = 1981:2012,
                           id = 1), by="id") %>% select(-id)
  
  df.simulated.all <- tribble(
    ~id, ~data,
    # Uncomment to include predictions of original data
    # "original", model.to.use@frame,
    "hypothetical", new.data
  ) %>%
    # Use simulate() instead of predict() to use the random effects in the predictions
    # https://tmalsburg.github.io/blog/predict-vs-simulate-in-lme4/
    mutate(simulated = data %>% 
             map(~ simulate(x, nsim=1, seed=1, 
                            newdata=select(.x, -total.oda_log_next_year), 
                            re.form=NA, allow.new.levels=TRUE))) %>%
    unnest()
  
  return(df.simulated.all)
}

simulated.h1.barriers.total <- mods.h1.next_year.melded %>%
  filter(model.name == "mod.h1.barriers.total") %>%
  unnest(data) %>%
  mutate(simulated = model %>% map(~ simulate.predictions.barriers(.))) %>%
  unnest(simulated)

df.plot.data <- simulated.h1.barriers.total %>%
  group_by(id, m, cowcode, barriers.total_within) %>%
  summarise_at(vars(starts_with("sim")), funs(avg = mean(.))) %>%
  ungroup() %>%
  gather(key, value, -c(id, m, cowcode, barriers.total_within))

df.plot.data.mean <- df.plot.data %>%
  group_by(barriers.total_within) %>%
  summarise(value = mean(value)) %>%
  mutate(value.exp = expm1(value)) %>%
  mutate(cowcode=1)  # Fake country so the line plots

fig.simulated.h1.barriers <- ggplot(df.plot.data, aes(x=barriers.total_within, 
                                                     y=expm1(value), group=cowcode)) + 
  geom_vline(xintercept=0, size=0.5) +
  geom_smooth(method="lm", size=0.1, alpha=0.1, colour="#DB9E36") +
  geom_smooth(data=df.plot.data.mean, size=1.5, method="lm", colour="#BD4932") +
  labs(x="Difference from average number of anti-NGO barriers in country\n(within effect)",
       y="Simulated ODA in the following year") +
  scale_y_continuous(labels=scales::dollar, trans=scales::log1p_trans()) +
  theme_donors()
```

The negative effect of anti-NGO barriers appears to be driven primarily by barriers to advocacy, such as laws restricting NGOs from engaging in political activities or government intimidation or dissolution of NGOs involved in politics. Adding a new barrier to advocacy above a country's average number of anti-advocacy laws is associated with a 46% drop in ODA in the following year (p < 0.1). Looking at the imposition of a new law rather than a change in the number of laws also yields a significant effect—a new anti-advocacy law is associated with a 100% drop in ODA in the following year. Notably, adding additional barriers to entry or funding has no noticeable effect on a country's aid in the following year. Additionally, the overall civil society regulatory environment in a country is also not associated with changes in aid. It appears that donors are more responsive to direct political intimidation and restriction than more benign bureaucratic legal barriers.

`TODO`: Overall level matters, not just the addition of one new law

`TODO`: Discuss the between coefficients; discuss aid leaded by 2 and 5 years

```{r h1-simulate-individual, warning=FALSE}
simulate.predictions.indiv.barriers <- function(x) {
  hypothetical.bounds <- x@frame %>%
    select(advocacy_within, entry_within, funding_within) %>%
    summarise_all(funs(min, max)) %>%
    gather(key, value) %>%
    mutate(value = round(value, 0)) %>%
    # Have to separate on _m because of multiple _s, then re-add the m
    separate(key, into=c("term", "variable"), sep="_m") %>%
    mutate(variable = paste0("m", variable)) %>%
    spread(variable, value)
  
  new.data.hypothetical.nested <- hypothetical.bounds %>%
    nest(-term) %>%
    mutate(newdata = map2(.x=data, .y=term,
                          ~ expand.grid(term = seq(.x$min, .x$max, by=0.5),
                                        cowcode = 1000:1050,
                                        year = 1981:2012,
                                        id = 1) %>%
                            # Rename the term column to the actual term name
                            magrittr::set_colnames(c(.y, colnames(.)[-1]))))
  
  new.data.hypothetical <- as_tibble(bind_rows(new.data.hypothetical.nested$newdata)) %>%
    mutate_at(vars(contains("within")), funs(ifelse(is.na(.), 0, .)))
  
  new.data <- x@frame %>%
    select(-c(advocacy_within, entry_within, funding_within, year, cowcode)) %>%
    summarise_all(typical) %>%
    mutate(id = 1,
           total.oda_log_next_year = NA) %>%
    right_join(new.data.hypothetical, by="id") %>% select(-id)
  
  df.simulated.all <- tribble(
    ~id, ~data,
    "hypothetical", new.data
  ) %>%
    mutate(simulated = data %>% 
             map(~ simulate(x, nsim=1, seed=1, 
                            newdata=select(.x, -total.oda_log_next_year), 
                            re.form=NA, allow.new.levels=TRUE))) %>%
    unnest()
  
  return(df.simulated.all)
}

barriers.indiv.clean.names <- tribble(
  ~barrier, ~barrier.clean,
  "advocacy_within", "Barriers to advocacy",
  "entry_within", "Barriers to entry",
  "funding_within", "Barriers to funding"
)

simulated.h1.barriers.indiv <- mods.h1.next_year.melded %>%
  filter(model.name == "mod.h1.type.total") %>%
  unnest(data) %>%
  mutate(simulated = model %>% map(~ simulate.predictions.indiv.barriers(.))) %>%
  unnest(simulated) %>%
  gather(barrier, barrier.value, c(advocacy_within, entry_within, funding_within))

df.plot.data.indiv <- simulated.h1.barriers.indiv %>%
  group_by(id, m, cowcode, barrier, barrier.value) %>%
  summarise_at(vars(starts_with("sim")), funs(avg = mean(.))) %>%
  ungroup() %>%
  gather(key, value, -c(id, m, cowcode, barrier, barrier.value)) %>%
  left_join(barriers.indiv.clean.names, by="barrier")

df.plot.data.mean.indiv <- df.plot.data.indiv %>%
  group_by(barrier, barrier.value) %>%
  summarise(value = mean(value)) %>%
  mutate(value.exp = expm1(value)) %>%
  mutate(cowcode=1) %>%  # Fake country so the line plots
  left_join(barriers.indiv.clean.names, by="barrier")

# fig.simulated.h1.barriers.indiv <- ggplot(df.plot.data.indiv, 
#                                           aes(x=barrier.value, y=expm1(value), 
#                                               group=cowcode)) + 
#   geom_vline(xintercept=0, size=0.5) +
#   geom_smooth(method="lm", size=0.1, alpha=0.1, colour="#DB9E36") +
#   geom_smooth(data=df.plot.data.mean.indiv, size=1.5, method="lm", colour="#BD4932") +
#   labs(x="Difference from average number of anti-NGO barriers in country\n(within effects)",
#        y="Simulated ODA in the following year") +
#   scale_y_continuous(labels=scales::dollar, trans=scales::log1p_trans()) +
#   facet_wrap(~ barrier.clean, scales="free_x") +
#   theme_donors()
```

```{r h1-simulate-both, warning=FALSE, fig.width=6.5, fig.height=4}
# Combine the two plot data frames
df.plot.data.both <- df.plot.data %>%
  mutate(barrier = "barriers.total_within", barrier.clean = "Total barriers") %>%
  rename(barrier.value = barriers.total_within) %>%
  bind_rows(df.plot.data.indiv) %>%
  mutate(barrier.clean = ordered(fct_inorder(barrier.clean)),
         highlight = ifelse(barrier.clean == "Total barriers", TRUE, FALSE))

df.plot.data.mean.both <- df.plot.data.mean %>%
  mutate(barrier = "barriers.total_within", barrier.clean = "Total barriers") %>%
  rename(barrier.value = barriers.total_within) %>%
  bind_rows(df.plot.data.mean.indiv) %>%
  mutate(barrier.clean = ordered(fct_inorder(barrier.clean)))

# Create data frame for highlighting the total panel
df.panel.highlight <- df.plot.data.both %>%
  distinct(barrier.clean, highlight)

fig.simulated.h1.barriers.both <- ggplot(df.plot.data.both, 
                                         aes(x=barrier.value, y=expm1(value), 
                                             group=cowcode)) + 
  geom_rect(data=df.panel.highlight, 
            aes(fill=highlight, x=NULL, y=NULL, group=NULL),
            xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf, alpha=0.15) +
  geom_vline(xintercept=0, size=0.5) +
  geom_smooth(method="lm", size=0.1, alpha=0.1, colour="#DB9E36") +
  geom_smooth(data=df.plot.data.mean.both, size=1.5, method="lm", colour="#BD4932") +
  labs(x="Difference from average number of anti-NGO barriers in country\n(within effects)",
       y="Simulated ODA in the following year") +
  scale_y_continuous(labels=scales::dollar, trans=scales::log1p_trans()) +
  scale_fill_manual(values=c(NA, "grey50"), guide=FALSE) +
  facet_wrap(~ barrier.clean, scales="free_x") +
  theme_donors()

fig.display.both <- fig.simulated.h1.barriers.both + 
  labs(title="Donors reduce aid more in response to\nadditional advocacy-focused anti-NGO laws",
       subtitle="Simulated foreign aid (ODA) across range of differences from the average number of\nanti-NGO laws in a hypothetical average country; dark line shows average of\n50 simulations across 5 imputed datasets",
       caption="Chaudhry and Heiss (2017)") + 
  theme_donors(11)

fig.simulated.h1.barriers.both
```

---

## H~2~: Donors shift aid to tamer causes

> **H~2~**: As restrictive laws against NGOs are enacted, donors start increasing funds for 'tamer' causes, and decreasing funds for politically sensitive causes.

Our dependent variable for this hypothesis is the percentage of ODA (still in constant 2011 dollars) allocated for contentious purposes, again leaded by one year. We classify contentious aid as any project focused on government and civil society (DAC codes 150 and 151) or conflict prevention and resolution, peace and security (DAC code 152).

Working with proportion data, however, poses interesting mathematical and methodological challenges, since the range of possible outcomes is limited to a value between 0 and 1. Treating proportion variables in a mixed model is technically possible, but it yields predicitions that go beyond the allowable range of values (1.13, -0.5, etc.). Treating the proportion as a binomial variable is also possible and is indeed [one of the ways to use the `glm()` function](http://stackoverflow.com/a/9111904/120898) in R. However, this entails considering the proportion as a ratio of success and failures. In this case, treating a dollar of contentious aid as a success feels off, especially since aid amounts aren't independence events—it's not like each dollar of aid goes through a probabalistic process likek a coin flip. Another solution is to use [beta regression](https://cran.r-project.org/package=betareg), which [constrains the outcome variable to values between 0 and 1](http://www.theanalysisfactor.com/zero-one-inflated-beta-models-for-proportion-data/), but unfortunately does not allow for values of exactly 0 or 1. Zero-and-one inflated beta regression models make adjustments for this, but [they aren't very popular](https://CRAN.R-project.org/package=zoib) and definitely don't accont for random effects and mixed models. 

[One recommendation by Ben Bolker](https://stat.ethz.ch/pipermail/r-sig-mixed-models/2011q1/015422.html), the maintainer of [`lme4`](https://cran.r-project.org/package=lme4), is to use a logit transformation of the dependent variable in `lmer()` models. This seems to be [standard practice in political science research](https://acrowinghen.com/2014/04/24/interpreting-coefficients-from-a-logit-linear-model-with-a-proportional-dependent-variable/), too. Logit transformations still can't handle values of exactly 0 or 1, though, so we [winsorize](https://en.wikipedia.org/wiki/Winsorizing) those values by adding or subtracting 0.001 to the extremes.

We thus use a logit-linear model of the ratio of contentious aid to non-contentious aid:

$$`r filter(all.models, h==2)$math`$$

We look at NGO legislation in the same ways as H~1~ and use the same controls.

```{r h2-models-1, warning=FALSE, message=FALSE, cache=TRUE}
# How to interpret logit-linear models:
# https://acrowinghen.com/2014/04/24/interpreting-coefficients-from-a-logit-linear-model-with-a-proportional-dependent-variable/
mods.h2.next_year.raw <- df.country.aid.demean.next_year.both %>%
  nest(-m) %>%
  mutate(mod.h2.barriers.total = data %>% map(mod.h2.barriers.total,
                                              "prop.contentious_logit_next_year"),
         mod.h2.barriers.new = data %>% map(mod.h2.barriers.new,
                                            "prop.contentious_logit_next_year"),
         mod.h2.type.total = data %>% map(mod.h2.type.total,
                                          "prop.contentious_logit_next_year"),
         mod.h2.type.new = data %>% map(mod.h2.type.new,
                                        "prop.contentious_logit_next_year"),
         mod.h2.csre = data %>% map(mod.h2.csre,
                                    "prop.contentious_logit_next_year"))

# Get model details and parameters
mods.h2.next_year <- mods.h2.next_year.raw %>%
  gather(model.name, model, -m, -data) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy, conf.int=TRUE))

# Meld the imputed models
mods.h2.next_year.melded <- mods.h2.next_year %>%
  filter(m != "original") %>%
  group_by(model.name) %>%
  nest() %>%
  mutate(tidy.melded = data %>% map(~ meld.imputed.models(., exponentiate=TRUE)))
```

### Results

Interpreting these coefficients is a little wonky because of how they're mathematically structured. The actual dependent variable is the natural log of the ratio of an in-group (here, contentious aid) to an outgroup (non-contentious aid). [It's easiest to interpret as a percentage change in the ratio of the in-group to the out-group](https://acrowinghen.com/2014/04/24/interpreting-coefficients-from-a-logit-linear-model-with-a-proportional-dependent-variable/), so the results should be seen as the predicted percentage change in the ratio of contentious to non-contentious aid. So, using this formula…

```{r change-bc-advocacy}
change.bc.advocacy <- mods.h2.next_year.melded %>%
  filter(model.name == "mod.h2.type.total") %>%
  select(tidy.melded) %>%
  unnest() %>%
  filter(term == "advocacy_within") %>%
  select(estimate) %>%
  mutate(transformed = (exp(estimate) - 1) * 100)
```

$$\% \Delta (\frac{\text{contentious aid}}{\text{noncontentious aid}}) = (e^{`r change.bc.advocacy$estimate`} - 1) \times 100 = `r change.bc.advocacy$transformed`$$

… we can say that countries that impose an additional barrier on advocacy have, on average, a `r scales::percent(abs(change.bc.advocacy$transformed) / 100)` `r ifelse(sign(change.bc.advocacy$transformed) == -1, "lower", "higher")` ratio of contentious aid to noncontentious aid, all else being equal.

```{r plot-h2-coefs, fig.width=7, fig.height=4}
vars.to.plot <- c("barriers.total_within", "barriers.total_between",
                  "barriers.total_new",
                  "advocacy_within", "advocacy_between", 
                  "entry_within", "entry_between", 
                  "funding_within", "funding_between",
                  "advocacy_new", "entry_new", "funding_new",
                  "csre_within", "csre_between")

coefs.raw.h2 <- mods.h2.next_year.melded %>%
  unnest(tidy.melded) %>%
  filter(term != "(Intercept)",
         term %in% vars.to.plot) %>%
  left_join(coef.names.all, by="term") %>%
  mutate(term = factor(term, levels=vars.to.plot, ordered=TRUE)) %>%
  arrange(desc(term)) %>%
  mutate(term_plot = ordered(fct_inorder(term_plot))) %>%
  mutate(coef.type = case_when(
    str_detect(.$term, "_within") ~ "Within",
    str_detect(.$term, "_between") ~ "Between",
    TRUE ~ "Not split"
  )) %>% 
  mutate(coef.type = factor(coef.type, levels=c("Within", "Between", "Not split"),
                            ordered=TRUE)) %>%
  mutate(model.name = factor(model.name, levels=rev(unique(model.name)), ordered=TRUE))

ggplot(coefs.raw.h2, aes(y=term_plot, x=or, colour=model.name)) + 
  geom_vline(xintercept=1, colour="grey50", size=1) + 
  geom_pointrangeh(aes(xmin=or.lower, xmax=or.upper), size=0.5) + 
  labs(x="Odds ratio", y=NULL) +
  scale_colour_manual(values=model.colors) +
  guides(color=FALSE) +
  theme_donors() + 
  facet_wrap(~ coef.type, scales="free")
```

```{r h2-melded-table-1, results="asis", warning=FALSE}
caption <- "The effect of anti-NGO legislation on the proportion of OECD overseas development assistance (ODA) committed to contentious purposes in the following year (H~2~), full models {#tbl:h2-coefs}"
note <- c("\\* *p* < 0.10; \\*\\* *p* < 0.05; \\*\\*\\* *p* < 0.01",
          "Logit-linear models. Odds ratios reported.",
          "Coefficients and standard errors\\ \naveraged across all imputations.")
table.h2 <- stargazer.fake(mods.h2.next_year.melded, exponentiate=TRUE, 
                           caption=caption, note=note)

cat(table.h2)
cat(table.h2, file=file.path(PROJHOME, "Output",
                             "tbl-h2-coefs.md"))
```

### Model diagnostics

Country intercepts vary with an SD of 0.661 (etc.), year intercepts vary with an SD of 0.704 (etc.), and the SD of error not accounted for by either within-country or within-year variability is 1.4 (etc.)

### Predicted proportion of contentious aid

```{r h2-simulate-both, warning=FALSE, fig.width=6.5, fig.height=4}
simulate.predictions.proportion.advocacy <- function(x) {
  new.data <- x@frame %>%
    select(-c(advocacy_within, year, cowcode)) %>%
    summarise_all(typical) %>%
    mutate(id = 1,
           prop.contentious_logit_next_year = NA) %>%
    right_join(expand.grid(advocacy_within = seq(-1, 2, 0.5),
                           cowcode = 1000:1050,
                           year = 1981:2012,
                           id = 1), by="id") %>% select(-id)
  
  df.simulated.all <- tribble(
    ~id, ~data,
    "hypothetical", new.data
  ) %>%
    mutate(simulated = data %>% 
             map(~ simulate(x, nsim=1, seed=1, 
                            newdata=select(.x, -prop.contentious_logit_next_year), 
                            re.form=NA, allow.new.levels=TRUE))) %>%
    unnest()
  
  return(df.simulated.all)
}

simulate.predictions.proportion.csre <- function(x) {
  new.data <- x@frame %>%
    select(-c(csre_within, year, cowcode)) %>%
    summarise_all(typical) %>%
    mutate(id = 1,
           prop.contentious_logit_next_year = NA) %>%
    right_join(expand.grid(csre_within = seq(-5, 5, 0.5),
                           cowcode = 1000:1050,
                           year = 1981:2012,
                           id = 1), by="id") %>% select(-id)
  
  df.simulated.all <- tribble(
    ~id, ~data,
    "hypothetical", new.data
  ) %>%
    mutate(simulated = data %>% 
             map(~ simulate(x, nsim=1, seed=1, 
                            newdata=select(.x, -prop.contentious_logit_next_year), 
                            re.form=NA, allow.new.levels=TRUE))) %>%
    unnest()
  
  return(df.simulated.all)
}

simulated.h2.advocacy <- mods.h2.next_year.melded %>%
  filter(model.name == "mod.h2.type.total") %>%
  unnest(data) %>%
  mutate(simulated = model %>% map(~ simulate.predictions.proportion.advocacy(.))) %>%
  unnest(simulated) %>%
  group_by(id, m, cowcode, advocacy_within) %>%
  summarise_at(vars(starts_with("sim")), funs(avg = mean(.))) %>%
  ungroup() %>%
  gather(key, value, -c(id, m, cowcode, advocacy_within)) %>%
  mutate(value.fixed = inv.logit(value, a=0.001),
         variable.clean = "Barriers to advocacy") %>%
  rename(variable = advocacy_within)

simulated.h2.csre <- mods.h2.next_year.melded %>%
  filter(model.name == "mod.h2.csre") %>%
  unnest(data) %>%
  mutate(simulated = model %>% map(~ simulate.predictions.proportion.csre(.))) %>%
  unnest(simulated) %>%
  group_by(id, m, cowcode, csre_within) %>%
  summarise_at(vars(starts_with("sim")), funs(avg = mean(.))) %>%
  ungroup() %>%
  gather(key, value, -c(id, m, cowcode, csre_within)) %>%
  mutate(value.fixed = inv.logit(value, a=0.001),
         variable.clean = "Civil society regulatory environment") %>%
  rename(variable = csre_within)

df.plot.data <- bind_rows(simulated.h2.advocacy, simulated.h2.csre)

df.plot.data.mean <- df.plot.data %>%
  group_by(variable.clean, variable) %>%
  summarise(value = mean(value)) %>%
  mutate(value.fixed = inv.logit(value, a=0.001)) %>%
  mutate(cowcode=1)  # Fake country so the line plots

fig.simulated.h2.barriers <- ggplot(df.plot.data, aes(x=variable, 
                                                     y=value.fixed, group=cowcode)) + 
  geom_vline(xintercept=0, size=0.5) +
  geom_smooth(method="lm", size=0.1, alpha=0.1, colour="#DB9E36") +
  geom_smooth(data=df.plot.data.mean, size=1.5, method="lm", colour="#BD4932") +
  labs(x="Difference from average level of NGO legislation in country\n(within effect)",
       y="Simulated proportion of contentious aid in the following year") +
  scale_y_continuous(labels=scales::percent) +
  facet_wrap(~ variable.clean, scales="free_x") +
  theme_donors()
fig.simulated.h2.barriers
```

---

## H~3~: Donors shift aid to international NGOs

> **H~3~**: As restrictive laws against local NGOs increase, states should be more likely to provide aid to INGOs rather than local NGOs.

We use two dependent variables for this hypothesis: the proportion of aid channeled through either (1) domestic or (2) international or US-based (or foreign) NGOs, once again leaded by one year. The OECD and AidData do not track the channels of aid delivery, so we cannot see how aid is distributed on a global scale. USAID, however, does track channels, so we can measure how much aid goes to domestic NGOs (and also US-based and international NGOs). USAID didn't start tracking this until 2001, though, so we have to limit our models to 2001–2013. (Boo.)

It would be cool to model the ratio aid channeled through domestic to foreign NGOs, but doing that causes weird mathematical issues with logit transformations, since the ratios can exceed 1. 

Because the DVs are proportions, we have to make the same assumptions and weird interpretive tricks as H~2~, building a logit-linear model of the ratio of domestic or foreign NGO aid to all other channels:

$$`r filter(all.models, h==3)$math`$$

Again, we use the same NGO legislation variables as H~1~ and H~2~ and use the same controls, except we omit "After 1989" since no observations actually occur after 1989.

```{r h3-models-1-domestic, warning=FALSE, message=FALSE, cache=TRUE}
mods.h3.dom.next_year.raw <- df.country.aid.us.demean.next_year.both %>%
  nest(-m) %>%
  mutate(mod.h3.barriers.total = data %>% map(mod.h3.barriers.total,
                                              "prop.ngo.dom_logit_next_year"),
         mod.h3.barriers.new = data %>% map(mod.h3.barriers.new,
                                            "prop.ngo.dom_logit_next_year"),
         mod.h3.type.total = data %>% map(mod.h3.type.total,
                                          "prop.ngo.dom_logit_next_year"),
         mod.h3.type.new = data %>% map(mod.h3.type.new,
                                        "prop.ngo.dom_logit_next_year"),
         mod.h3.csre = data %>% map(mod.h3.csre,
                                    "prop.ngo.dom_logit_next_year"))

# Get model details and parameters
mods.h3.dom.next_year <- mods.h3.dom.next_year.raw %>%
  gather(model.name, model, -m, -data) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy, conf.int=TRUE))

# Meld the imputed models
mods.h3.dom.next_year.melded <- mods.h3.dom.next_year %>%
  filter(m != "original") %>%
  group_by(model.name) %>%
  nest() %>%
  mutate(tidy.melded = data %>% map(~ meld.imputed.models(., exponentiate=TRUE)))
```

```{r h3-models-1-foreign, warning=FALSE, message=FALSE, cache=TRUE}
mods.h3.foreign.next_year.raw <- df.country.aid.us.demean.next_year.both %>%
  nest(-m) %>%
  mutate(mod.h3.barriers.total = data %>% map(mod.h3.foreign.barriers.total,
                                              "prop.ngo.foreign_logit_next_year"),
         mod.h3.barriers.new = data %>% map(mod.h3.foreign.barriers.new,
                                            "prop.ngo.foreign_logit_next_year"),
         mod.h3.type.total = data %>% map(mod.h3.foreign.type.total,
                                          "prop.ngo.foreign_logit_next_year"),
         mod.h3.type.new = data %>% map(mod.h3.foreign.type.new,
                                        "prop.ngo.foreign_logit_next_year"),
         mod.h3.csre = data %>% map(mod.h3.foreign.csre,
                                    "prop.ngo.foreign_logit_next_year"))

# Get model details and parameters
mods.h3.foreign.next_year <- mods.h3.foreign.next_year.raw %>%
  gather(model.name, model, -m, -data) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy, conf.int=TRUE))

# Meld the imputed models
mods.h3.foreign.next_year.melded <- mods.h3.foreign.next_year %>%
  filter(m != "original") %>%
  group_by(model.name) %>%
  nest() %>%
  mutate(tidy.melded = data %>% map(~ meld.imputed.models(., exponentiate=TRUE)))
```

### Results

#### Proportion to domestic NGOs

```{r plot-h3-coefs-domestic, fig.width=7, fig.height=4}
vars.to.plot <- c("barriers.total_within", "barriers.total_between",
                  "barriers.total_new",
                  "advocacy_within", "advocacy_between", 
                  "entry_within", "entry_between", 
                  "funding_within", "funding_between",
                  "advocacy_new", "entry_new", "funding_new",
                  "csre_within", "csre_between")

coefs.raw.h3.dom <- mods.h3.dom.next_year.melded %>%
  unnest(tidy.melded) %>%
  filter(term != "(Intercept)",
         term %in% vars.to.plot) %>%
  left_join(coef.names.all, by="term") %>%
  mutate(term = factor(term, levels=vars.to.plot, ordered=TRUE)) %>%
  arrange(desc(term)) %>%
  mutate(term_plot = ordered(fct_inorder(term_plot))) %>%
  mutate(coef.type = case_when(
    str_detect(.$term, "_within") ~ "Within",
    str_detect(.$term, "_between") ~ "Between",
    TRUE ~ "Not split"
  )) %>% 
  mutate(coef.type = factor(coef.type, levels=c("Within", "Between", "Not split"),
                            ordered=TRUE)) %>%
  mutate(model.name = factor(model.name, levels=rev(unique(model.name)), ordered=TRUE))
```

```{r h3-melded-table-1-domestic, results="asis", warning=FALSE}
caption <- "The effect of anti-NGO legislation on the proportion of US aid channeled through *domestic* NGOs in the following year (H~3~), full models {#tbl:h3-domestic-coefs}"
note <- c("\\* *p* < 0.10; \\*\\* *p* < 0.05; \\*\\*\\* *p* < 0.01",
          "Logit-linear models. Odds ratios reported.",
          "Coefficients and standard errors\\ \naveraged across all imputations.")
table.h3.domestic <- stargazer.fake(mods.h3.dom.next_year.melded, exponentiate=TRUE, 
                                    caption=caption, note=note)

cat(table.h3.domestic)
cat(table.h3.domestic, file=file.path(PROJHOME, "Output",
                                      "tbl-h3-domestic-coefs.md"))
```

#### Proportion to foreign NGOs

```{r plot-h3-coefs-foreign, fig.width=5, fig.height=4}
vars.to.plot <- c("barriers.total_within", "barriers.total_between",
                  "barriers.total_new",
                  "advocacy_within", "advocacy_between", 
                  "entry_within", "entry_between", 
                  "funding_within", "funding_between",
                  "advocacy_new", "entry_new", "funding_new",
                  "csre_within", "csre_between")

coefs.raw.h3.foreign <- mods.h3.foreign.next_year.melded %>%
  unnest(tidy.melded) %>%
  filter(term != "(Intercept)",
         term %in% vars.to.plot) %>%
  left_join(coef.names.all, by="term") %>%
  mutate(term = factor(term, levels=vars.to.plot, ordered=TRUE)) %>%
  arrange(desc(term)) %>%
  mutate(term_plot = ordered(fct_inorder(term_plot))) %>%
  mutate(coef.type = case_when(
    str_detect(.$term, "_within") ~ "Within",
    str_detect(.$term, "_between") ~ "Between",
    TRUE ~ "Not split"
  )) %>% 
  mutate(coef.type = factor(coef.type, levels=c("Within", "Between", "Not split"),
                            ordered=TRUE)) %>%
  mutate(model.name = factor(model.name, levels=rev(unique(model.name)), ordered=TRUE))
```

```{r h3-melded-table-1-foreign, results="asis", warning=FALSE}
caption <- "The effect of anti-NGO legislation on the proportion of US aid channeled through *US-based and international* NGOs in the following year (H~3~), full models {#tbl:h3-foreign-coefs}"
note <- c("\\* *p* < 0.10; \\*\\* *p* < 0.05; \\*\\*\\* *p* < 0.01",
          "Logit-linear models. Odds ratios reported.",
          "Coefficients and standard errors\\ \naveraged across all imputations.")
table.h3.foreign <- stargazer.fake(mods.h3.foreign.next_year.melded, exponentiate=TRUE, 
                                   caption=caption, note=note)

cat(table.h3.foreign)
cat(table.h3.foreign, file=file.path(PROJHOME, "Output",
                                     "tbl-h3-foreign-coefs.md"))
```

```{r plot-h3-coefs-both, fig.width=7, fig.height=4}
coefs.h3.both <- bind_rows(`Domestic NGOs` = coefs.raw.h3.dom,
                           `Foreign NGOs` = coefs.raw.h3.foreign,
                           .id="channel")

ggplot(coefs.h3.both, aes(y=term_plot, x=or, colour=interaction(model.name, channel))) + 
  geom_vline(xintercept=1, colour="grey50", size=1) + 
  geom_pointrangeh(aes(xmin=or.lower, xmax=or.upper, shape=channel), size=0.5,
                   position=position_dodgev(height=0.5)) + 
  labs(x="Odds ratio", y=NULL) +
  scale_colour_manual(values=c(model.colors, model.colors)) +
  guides(color=FALSE, shape=guide_legend(title=NULL)) +
  theme_donors() +
  facet_wrap(~ coef.type, scales="free")
```


### Model diagnostics


### Predicted proprtion of aid channeled to domestic or foreign NGOs

```{r h3-simulate-both, warning=FALSE, fig.width=6.5, fig.height=4}
simulate.predictions.prop.foreign.ngo.funding <- function(x) {
  new.data <- x@frame %>%
    select(-c(funding_within, year, cowcode)) %>%
    summarise_all(typical) %>%
    mutate(id = 1,
           prop.ngo.foreign_logit_next_year = NA) %>%
    right_join(expand.grid(funding_within = seq(-2, 4, 0.5),
                           cowcode = 1000:1050,
                           year = 2000:2012,
                           id = 1), by="id") %>% select(-id)
  
  df.simulated.all <- tribble(
    ~id, ~data,
    "hypothetical", new.data
  ) %>%
    mutate(simulated = data %>% 
             map(~ simulate(x, nsim=1, seed=1, 
                            newdata=select(.x, -prop.ngo.foreign_logit_next_year), 
                            re.form=NA, allow.new.levels=TRUE))) %>%
    unnest()
  
  return(df.simulated.all)
}

simulate.predictions.prop.domestic.ngo.funding <- function(x) {
  new.data <- x@frame %>%
    select(-c(funding_within, year, cowcode)) %>%
    summarise_all(typical) %>%
    mutate(id = 1,
           prop.ngo.dom_logit_next_year = NA) %>%
    right_join(expand.grid(funding_within = seq(-2, 4, 0.5),
                           cowcode = 1000:1050,
                           year = 2000:2012,
                           id = 1), by="id") %>% select(-id)
  
  df.simulated.all <- tribble(
    ~id, ~data,
    "hypothetical", new.data
  ) %>%
    mutate(simulated = data %>% 
             map(~ simulate(x, nsim=1, seed=1, 
                            newdata=select(.x, -prop.ngo.dom_logit_next_year), 
                            re.form=NA, allow.new.levels=TRUE))) %>%
    unnest()
  
  return(df.simulated.all)
}

simulated.h3.foreign.funding <- mods.h3.foreign.next_year.melded %>%
  filter(model.name == "mod.h3.type.total") %>%
  unnest(data) %>%
  mutate(simulated = model %>% map(~ simulate.predictions.prop.foreign.ngo.funding(.))) %>%
  unnest(simulated) %>%
  group_by(id, m, cowcode, funding_within) %>%
  summarise_at(vars(starts_with("sim")), funs(avg = mean(.))) %>%
  ungroup() %>%
  gather(key, value, -c(id, m, cowcode, funding_within)) %>%
  mutate(value.fixed = inv.logit(value, a=0.001),
         variable.clean = "Aid through foreign NGOs") %>%
  rename(variable = funding_within)

simulated.h3.domestic.funding <- mods.h3.dom.next_year.melded %>%
  filter(model.name == "mod.h3.type.total") %>%
  unnest(data) %>%
  mutate(simulated = model %>% map(~ simulate.predictions.prop.domestic.ngo.funding(.))) %>%
  unnest(simulated) %>%
  group_by(id, m, cowcode, funding_within) %>%
  summarise_at(vars(starts_with("sim")), funs(avg = mean(.))) %>%
  ungroup() %>%
  gather(key, value, -c(id, m, cowcode, funding_within)) %>%
  mutate(value.fixed = inv.logit(value, a=0.001),
         variable.clean = "Aid through domestic NGOs") %>%
  rename(variable = funding_within)

df.plot.data <- bind_rows(simulated.h3.foreign.funding,
                          simulated.h3.domestic.funding)

df.plot.data.mean <- df.plot.data %>%
  group_by(variable.clean, variable) %>%
  summarise(value = mean(value)) %>%
  mutate(value.fixed = inv.logit(value, a=0.001)) %>%
  mutate(cowcode=1)  # Fake country so the line plots

fig.simulated.h3.barriers <- ggplot(df.plot.data, aes(x=variable, 
                                                      y=value.fixed, group=cowcode)) + 
  geom_vline(xintercept=0, size=0.5) +
  geom_smooth(method="lm", size=0.1, alpha=0.1, colour="#DB9E36") +
  geom_smooth(data=df.plot.data.mean, size=1.5, method="lm", colour="#BD4932") +
  labs(x="Difference from average number of barriers to funding\n(within effect)",
       y="Simulated proportion of aid to type of NGO in the following year") +
  scale_y_continuous(labels=scales::percent) +
  facet_wrap(~ variable.clean, scales="free_x") +
  theme_donors()
fig.simulated.h3.barriers
```


---

## H~4~: Donors shift aid to neighboring countries

> **H~4~**: As restrictive laws against NGOs in a country are enacted, donors should be more likely to provide aid to neighboring countries.

Our dependent variable for this hypothesis is the total amount of ODA given to countries within 900 km of a country's border, capturing aid given to the overall neighborhood. The model is structured similarly to H~1~, using just the log of aid rather than any proportional measure, which makes interpreting the coefficients a lot easier (yay!): 

$$`r filter(all.models, h==4)$math`$$

With the dependent variable specified like this, it makes less sense to use country-level random effects, since the unit of analysis is essentially the entire neighborhood, not a single country. We're looking at the effect of one country's regulations, wealth, democracy, corruption, and bad stuff on the overall neighborhood's aid. 

```{r h4-models-1, warning=FALSE, message=FALSE, cache=TRUE}
# Run models on each of the datasets (original and imputed) and save in a big data frame
mods.h4.next_year.raw <- df.country.aid.demean.next_year.both %>%
  nest(-m) %>%
  mutate(mod.h4.barriers.total = data %>% map(mod.h4.barriers.total,
                                              "nb_oda.sum_log_next_year"),
         mod.h4.barriers.new = data %>% map(mod.h4.barriers.new,
                                            "nb_oda.sum_log_next_year"),
         mod.h4.type.total = data %>% map(mod.h4.type.total,
                                          "nb_oda.sum_log_next_year"),
         mod.h4.type.new = data %>% map(mod.h4.type.new,
                                        "nb_oda.sum_log_next_year"),
         mod.h4.csre = data %>% map(mod.h4.csre,
                                    "nb_oda.sum_log_next_year"))

# Get model details and parameters
mods.h4.next_year <- mods.h4.next_year.raw %>%
  gather(model.name, model, -m, -data) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy, conf.int=TRUE))

# Meld the imputed models
mods.h4.next_year.melded <- mods.h4.next_year %>%
  filter(m != "original") %>%
  group_by(model.name) %>%
  nest() %>%
  mutate(tidy.melded = data %>% map(meld.imputed.models))
```

### Results

```{r plot-h4-coefs, fig.width=5, fig.height=4}
vars.to.plot <- c("barriers.total", "barriers.total_new",
                  "advocacy", "entry", "funding",
                  "advocacy_new", "entry_new", "funding_new",
                  "csre")

coefs.raw.h4 <- mods.h4.next_year.melded %>%
  unnest(tidy.melded) %>%
  filter(term != "(Intercept)",
         term %in% vars.to.plot) %>%
  left_join(coef.names.all, by="term") %>%
  mutate(term = factor(term, levels=vars.to.plot, ordered=TRUE)) %>%
  arrange(desc(term)) %>%
  mutate(term_plot = ordered(fct_inorder(term_plot))) %>%
  mutate(model.name = factor(model.name, levels=rev(unique(model.name)), ordered=TRUE))

ggplot(coefs.raw.h4, aes(y=term_plot, x=estimate, colour=model.name)) + 
  geom_vline(xintercept=0, colour="grey50", size=0.5) + 
  geom_pointrangeh(aes(xmin=conf.low, xmax=conf.high), size=.5) + 
  labs(x="Estimate", y=NULL) +
  scale_colour_manual(values=model.colors) +
  guides(color=FALSE) +
  theme_donors()
```

```{r h4-melded-table-1, results="asis", warning=FALSE}
caption <- "The effect of anti-NGO legislation on OECD overseas development assistance (ODA) in countries within 900 km radius in the following year (H~4~), full models {#tbl:h4-coefs}"
note <- c("\\* *p* < 0.10; \\*\\* *p* < 0.05; \\*\\*\\* *p* < 0.01",
          "Dependent variable log transformed.",
          "Coefficients and standard errors\\ \naveraged across all imputations.")

table.h4 <- stargazer.fake(mods.h4.next_year.melded, 
                           caption=caption, note=note)

cat(table.h4)
cat(table.h4, file=file.path(PROJHOME, "Output",
                             "tbl-h4-coefs.md"))
```

### Model diagnostics


### Predicted ODA to all neighbors

```{r h4-simulate-total, warning=FALSE, fig.width=6}
simulate.predictions.barriers <- function(x) {
  new.data <- x@frame %>%
    select(-c(barriers.total, year)) %>%
    summarise_all(typical) %>%
    mutate(id = 1,
           nb_oda.sum_log_next_year = NA) %>%
    right_join(expand.grid(barriers.total = seq(0, 12, 0.5),
                           year = 1981:2012,
                           id = 1), by="id") %>% select(-id)
  
  df.simulated.all <- tribble(
    ~id, ~data,
    # Uncomment to include predictions of original data
    # "original", model.to.use@frame,
    "hypothetical", new.data
  ) %>%
    # Use simulate() instead of predict() to use the random effects in the predictions
    # https://tmalsburg.github.io/blog/predict-vs-simulate-in-lme4/
    mutate(simulated = data %>% 
             map(~ simulate(x, nsim=1, seed=1, 
                            newdata=select(.x, -nb_oda.sum_log_next_year), 
                            re.form=NA, allow.new.levels=TRUE))) %>%
    unnest()
  
  return(df.simulated.all)
}

simulated.h4.barriers.total <- mods.h4.next_year.melded %>%
  filter(model.name == "mod.h4.barriers.total") %>%
  unnest(data) %>%
  mutate(simulated = model %>% map(~ simulate.predictions.barriers(.))) %>%
  unnest(simulated)

df.plot.data <- simulated.h4.barriers.total %>%
  group_by(id, m, barriers.total) %>%
  summarise_at(vars(starts_with("sim")), funs(avg = mean(.))) %>%
  ungroup() %>%
  gather(key, value, -c(id, m, barriers.total)) %>%
  group_by(barriers.total) %>%
  summarise(value = mean(value))
```

```{r h4-simulate-individual, warning=FALSE}
simulate.predictions.indiv.barriers <- function(x) {
  hypothetical.bounds <- x@frame %>%
    select(advocacy, entry, funding) %>%
    summarise_all(funs(min, max)) %>%
    gather(key, value) %>%
    mutate(value = round(value, 0)) %>%
    # Have to separate on _m because of multiple _s, then re-add the m
    separate(key, into=c("term", "variable"), sep="_m") %>%
    mutate(variable = paste0("m", variable)) %>%
    spread(variable, value)
  
  new.data.hypothetical.nested <- hypothetical.bounds %>%
    nest(-term) %>%
    mutate(newdata = map2(.x=data, .y=term,
                          ~ expand.grid(term = seq(.x$min, .x$max, by=0.5),
                                        year = 1981:2012,
                                        id = 1) %>%
                            # Rename the term column to the actual term name
                            magrittr::set_colnames(c(.y, colnames(.)[-1]))))
  
  new.data.hypothetical <- as_tibble(bind_rows(new.data.hypothetical.nested$newdata)) %>%
    mutate_at(vars(advocacy, entry, funding), funs(ifelse(is.na(.), 0, .)))
  
  new.data <- x@frame %>%
    select(-c(advocacy, entry, funding, year)) %>%
    summarise_all(typical) %>%
    mutate(id = 1,
           nb_oda.sum_log_next_year = NA) %>%
    right_join(new.data.hypothetical, by="id") %>% select(-id)
  
  df.simulated.all <- tribble(
    ~id, ~data,
    "hypothetical", new.data
  ) %>%
    mutate(simulated = data %>% 
             map(~ simulate(x, nsim=1, seed=1, 
                            newdata=select(.x, -nb_oda.sum_log_next_year), 
                            re.form=NA, allow.new.levels=TRUE))) %>%
    unnest()
  
  return(df.simulated.all)
}

barriers.indiv.clean.names <- tribble(
  ~barrier, ~barrier.clean,
  "advocacy", "Barriers to advocacy",
  "entry", "Barriers to entry",
  "funding", "Barriers to funding"
)

simulated.h4.barriers.indiv <- mods.h4.next_year.melded %>%
  filter(model.name == "mod.h4.type.total") %>%
  unnest(data) %>%
  mutate(simulated = model %>% map(~ simulate.predictions.indiv.barriers(.))) %>%
  unnest(simulated) %>%
  gather(barrier, barrier.value, c(advocacy, entry, funding))

df.plot.data.indiv <- simulated.h4.barriers.indiv %>%
  group_by(id, m, barrier, barrier.value) %>%
  summarise_at(vars(starts_with("sim")), funs(avg = mean(.))) %>%
  ungroup() %>%
  gather(key, value, -c(id, m, barrier, barrier.value)) %>%
  group_by(barrier, barrier.value) %>%
  summarise(value = mean(value)) %>%
  left_join(barriers.indiv.clean.names, by="barrier")
```

```{r h4-simulate-both, warning=FALSE, fig.width=6.5, fig.height=4}
# Combine the two plot data frames
df.plot.data.both <- df.plot.data %>%
  mutate(barrier = "barriers.total", barrier.clean = "Total barriers") %>%
  rename(barrier.value = barriers.total) %>%
  bind_rows(df.plot.data.indiv) %>%
  mutate(barrier.clean = ordered(fct_inorder(barrier.clean)),
         highlight = ifelse(barrier.clean == "Total barriers", TRUE, FALSE))

# Create data frame for highlighting the total panel
df.panel.highlight <- df.plot.data.both %>%
  distinct(barrier.clean, highlight)

fig.simulated.h4.barriers.both <- ggplot(df.plot.data.both, 
                                         aes(x=barrier.value, y=expm1(value))) + 
  geom_rect(data=df.panel.highlight, 
            aes(fill=highlight, x=NULL, y=NULL, group=NULL),
            xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf, alpha=0.15) +
  geom_smooth(size=1.5, method="lm", colour="#BD4932") +
  labs(x="Hypothetical anti-NGO legal barriers",
       y="Simulated neighborhood ODA in the following year") +
  scale_y_continuous(labels=scales::dollar, trans=scales::log1p_trans()) +
  scale_x_continuous(breaks=integer_breaks()) +
  scale_fill_manual(values=c(NA, "grey50"), guide=FALSE) +
  facet_wrap(~ barrier.clean, scales="free_x") +
  theme_donors()

fig.simulated.h4.barriers.both
```

---

## Robustness checks

### Imputation

[As discussed over in the data cleaning file](../Data/get_merge_data.html#missingness_and_imputation), we impute data for the few variables that are missing. To show what difference imputation makes, the table below shows three pairs of models from H~1~. The first two models are run on non-imputed data (so missing observations are deleted listwise), the second two models are run on 5 sets of imputed data, and the last two models are run on 10 sets of imputed data. 

It's clear that imputation makes a substantial difference—note the big differences between coefficients. However, the number of imputed datasets doesn't seem to matter, since there are only trivial differences in coefficients when there are 5 and 10 datasets.

```{r robust-compare-imputations, message=FALSE, warning=FALSE, cache=TRUE}
mods.robust.check.m.next_year.raw <- df.country.aid.demean.next_year.all %>%
  nest(-m) %>%
  mutate(mod.h1.barriers.total = data %>% map(mod.h1.barriers.total,
                                              "total.oda_log_next_year"),
         mod.h1.type.total = data %>% map(mod.h1.type.total,
                                          "total.oda_log_next_year"))

# Get model details and parameters
mods.robust.check.m.next_year <- mods.robust.check.m.next_year.raw %>%
  gather(model.name, model, -m, -data) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy, conf.int=TRUE))

# Meld the imputed models
mods.robust.check.m.next_year.melded.original <- mods.robust.check.m.next_year %>%
  filter(m == "original") %>%
  group_by(model.name) %>%
  nest() %>%
  mutate(tidy.melded = data %>% map(meld.imputed.models))

mods.robust.check.m.next_year.melded.m5 <- mods.robust.check.m.next_year %>%
  filter(m %in% paste0("imp", 1:5)) %>%
  group_by(model.name) %>%
  nest() %>%
  mutate(tidy.melded = data %>% map(meld.imputed.models))

mods.robust.check.m.next_year.melded.m10 <- mods.robust.check.m.next_year %>%
  filter(m != "original") %>%
  group_by(model.name) %>%
  nest() %>%
  mutate(tidy.melded = data %>% map(meld.imputed.models))

mods.robust.check.m.next_year.melded.all <- bind_rows(
  mods.robust.check.m.next_year.melded.original,
  mods.robust.check.m.next_year.melded.m5,
  mods.robust.check.m.next_year.melded.m10
) %>%
  mutate(imputations = data %>% map_dbl(~ nrow(.)),
         model.name = paste(model.name, imputations, sep="_"))
```

```{r tbl-show-imputations, results="asis"}
stargazer.fake(mods.robust.check.m.next_year.melded.all) %>% cat()
```

### Longer lags

Looking at aid 2 years and 5 years after the change in anti-NGO legislation shows similar trends to 1 year after.

```{r h1-models-2, warning=FALSE, message=FALSE, cache=TRUE}
mods.h1.after_2.raw <- df.country.aid.demean.after_2.impute %>%
  nest(-m) %>%
  mutate(mod.h1.barriers.total = data %>% map(mod.h1.barriers.total,
                                              "total.oda_log_next_year"),
         mod.h1.barriers.new = data %>% map(mod.h1.barriers.new,
                                            "total.oda_log_next_year"),
         mod.h1.type.total = data %>% map(mod.h1.type.total,
                                          "total.oda_log_next_year"),
         mod.h1.type.new = data %>% map(mod.h1.type.new,
                                        "total.oda_log_next_year"),
         mod.h1.csre = data %>% map(mod.h1.csre,
                                    "total.oda_log_next_year"))

# Get model details and parameters
mods.h1.after_2 <- mods.h1.after_2.raw %>%
  gather(model.name, model, -m, -data) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy, conf.int=TRUE))

# Meld the imputed models
mods.h1.after_2.melded <- mods.h1.after_2 %>%
  filter(m != "original") %>%
  group_by(model.name) %>%
  nest() %>%
  mutate(tidy.melded = data %>% map(meld.imputed.models))
```

```{r h1-models-5, warning=FALSE, message=FALSE, cache=TRUE}
mods.h1.after_5.raw <- df.country.aid.demean.after_5.impute %>%
  nest(-m) %>%
  mutate(mod.h1.barriers.total = data %>% map(mod.h1.barriers.total,
                                              "total.oda_log_next_year"),
         mod.h1.barriers.new = data %>% map(mod.h1.barriers.new,
                                            "total.oda_log_next_year"),
         mod.h1.type.total = data %>% map(mod.h1.type.total,
                                          "total.oda_log_next_year"),
         mod.h1.type.new = data %>% map(mod.h1.type.new,
                                        "total.oda_log_next_year"),
         mod.h1.csre = data %>% map(mod.h1.csre,
                                    "total.oda_log_next_year"))

# Get model details and parameters
mods.h1.after_5 <- mods.h1.after_5.raw %>%
  gather(model.name, model, -m, -data) %>%
  mutate(glance = model %>% map(broom::glance),
         tidy = model %>% map(broom::tidy, conf.int=TRUE))

# Meld the imputed models
mods.h1.after_5.melded <- mods.h1.after_5 %>%
  filter(m != "original") %>%
  group_by(model.name) %>%
  nest() %>%
  mutate(tidy.melded = data %>% map(meld.imputed.models))
```

#### Effect on ODA after 2 years

```{r h1-melded-table-2, results="asis", warning=FALSE}
stargazer.fake(mods.h1.after_2.melded) %>% cat()
```

#### Effect on ODA after 5 years

```{r h1-melded-table-5, results="asis", warning=FALSE}
stargazer.fake(mods.h1.after_5.melded) %>% cat()
```
